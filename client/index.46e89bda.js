import{S as e,i as t,s as n,M as a,c as o,a as r,e as s,t as i,q as h,j as l,d as c,f as d,b as u,g as m,h as g,k as f,n as p,m as v,l as w,p as b,r as y,u as E,H as k}from"./client.311a5b93.js";import"./Icon.06acf308.js";import{M as x,P as I}from"./MetaTags.39c5eacd.js";import{H as $,j as T}from"./index.ec9d7c60.js";import{c as P}from"./cover.4038dd1b.js";function L(e){let t,n,k,L,C,A,H,O,S,j,q,W,D,R,M,B,N,F,G,K,z,U,Y,J,Q,V,X,Z,_,ee,te,ne,ae,oe,re,se,ie,he,le,ce,de,ue,me,ge,fe,pe,ve,we,be,ye,Ee,ke,xe,Ie,$e,Te,Pe,Le,Ce,Ae,He,Oe,Se,je,qe,We,De,Re,Me,Be,Ne,Fe,Ge,Ke,ze,Ue,Ye,Je,Qe,Ve,Xe,Ze,_e,et,tt,nt,at,ot,rt,st,it,ht,lt,ct,dt,ut,mt,gt,ft,pt,vt,wt,bt,yt,Et,kt,xt,It,$t,Tt,Pt,Lt,Ct,At,Ht,Ot,St,jt,qt,Wt,Dt,Rt,Mt,Bt,Nt,Ft,Gt,Kt,zt,Ut,Yt,Jt,Qt,Vt,Xt,Zt,_t,en,tn,nn,an,on,rn,sn,hn,ln,cn,dn,un,mn,gn,fn,pn,vn,wn,bn,yn,En,kn,xn,In,$n,Tn,Pn,Ln,Cn,An,Hn;return t=new x({props:{title:"Keeping global state management sane with rel-events",description:"In this post, we'll discuss how to use rel-events to keep your React app's state sane :]",keywords:"rel-events, react, redux, big projects, architecture, planning, frontend, javascript, frameworks"}}),H=new I({props:{date:"2019-10-19",text:e[1]}}),ct=new $({props:{language:T,code:a('\nimport { HTTPEvent } from "rel-events";\n\nexport const LoginEvent = new HTTPEvent({ name: "login" });\n')}}),ft=new $({props:{language:T,code:a('\nimport { HTTPEvent } from "rel-events";\nimport { LoginEventManager } from "./eventManagers";\n\nexport const LoginEvent = new HTTPEvent({\n  name: "login",\n  manager: new LoginEventManager(),\n});\n')}}),yt=new $({props:{language:T,code:a('\nimport { fetchFromApi } from "rel-events";\n\nexport class LoginEventManager {\n  initialState = { isLoading: false, username: "Anonymous" };\n\n  call = (user) => {\n    return () => fetchFromApi(\n      "/api/login",\n      { method: "POST", body: JSON.stringify(user) }\n    );\n  }\n\n  onDispatch = (state, event) => ({\n    ...state,\n    isLoading: true,\n    username: this.initialState.username\n  })\n\n  onSuccess = (state, event) => ({\n    ...state,\n    isLoading: this.initialState.isLoading,\n    username: event.response.data.username\n  })\n\n  onFailure = (state, event) => ({\n    ...state,\n    isLoading: this.initialState.isLoading,\n    username: this.initialState.username,\n    error: event.error.data\n  })\n});\n')}}),$t=new $({props:{language:T,code:a('\n// LoginComponent.js\nimport React from "react";\nimport { LoginEvent } from "./events";\n\nexport class LoginComponent extends React.Component {\n  handleSubmit = () => {\n    const { user } = this.state;\n    // the Event injects its trigger as a prop with its own name ("login")\n    const { login } = this.props;\n\n    login(user);\n  }\n\n  render() {\n    const { username } = this.props;\n    return (\n      <React.Fragment>\n        <h1>Hello, {username}</h1>\n        <form>{ /* inputs and submit button */ }</form>\n      </React.Fragment>\n    );\n  }\n});\n\n// and here, we register the Component in the Event,\n// which injects its trigger as props (as described above),\n// and we also ask for the Events "username" value to be injected as well\nexport default LoginEvent.register({\n  Component: LoginComponent,\n  props: ["username"]\n});\n')}}),{c(){o(t.$$.fragment),n=r(),k=s("h1"),L=s("mark"),C=i("Keeping global state management sane with rel-events"),A=r(),o(H.$$.fragment),O=r(),S=s("figure"),j=s("img"),W=r(),D=s("article"),R=s("p"),M=i("Maintaining a big and complex react app is not for amateurs. Whatever you\n    may choose to manage your app state, chances are that it's hard to pick up,\n    like redux, or really convoluted, like making yourself a service layer. With\n    the goal of making it easy for new developers to jump into our projects, we\n    at Labcodes decided it was time to give this problem a little more thought.\n    Our answer was\n    "),B=s("a"),N=i("rel-events"),F=i("."),G=r(),K=s("h2"),z=i("Why another library to manage states?"),U=r(),Y=s("p"),J=s("a"),Q=s("img"),X=r(),Z=s("p"),_=i("Whenever I think of making something new and shiny, this xkcd strip comes to\n    haunt me. Believe me, I don't want to be the kind of person that does\n    everything themselves, and that's one of my grievances with the fork\n    mentality. However, it was about time I did something to address a pesky\n    problem I deal with daily: using whatever library to separate business logic\n    from react components."),ee=r(),te=s("p"),ne=i("At the end of the day, after much thought, I always end up surrendering and\n    running\n    "),ae=s("code"),oe=i("npm install redux react-redux --save"),re=i(". I even shared my basic\n    tools to deal with redux on our\n    "),se=s("a"),ie=s("code"),he=i("react-redux-api-tools"),le=i("\n    package."),ce=r(),de=s("p"),ue=i("And by no means I hate redux; in fact, I love it. It gets the job done, it's\n    ultra flexible, with low side effects. But let's be frank here: the\n    discomfort of reading\n    "),me=s("code"),ge=i("mapStateToProps"),fe=i("\n    for the first time is\n    "),pe=s("strong"),ve=i("real"),we=i(". It took me a long while to properly understand what\n    was going on. Then there are actions, action creators, reducers, dispatches\n    and middlewares, and sagas, and async dispatches; it's neverending."),be=r(),ye=s("p"),Ee=i("After those confusing and long first months, things started to get easier,\n    but way,\n    "),ke=s("strong"),xe=i("way"),Ie=i("\n    too verbose. I always thought that redux felt a lower level tool, and that I\n    was always in need of specifying, step by step, exactly and strictly what\n    and how things should be done. No abstraction at all. A lot of copy and\n    paste, though."),$e=r(),Te=s("p"),Pe=i("I came to the conclusion that it would be nice to have all the features I\n    would like in my redux configuration - a proper HTTP request flow, less\n    repetition, meaningful connection between actions and reducers -, without\n    sacrificing anything. I got the green light to develop internally a solution\n    for that:\n    "),Le=s("code"),Ce=i("rel-events"),Ae=i("."),He=r(),Oe=s("h2"),Se=i("Cool, but what's "),je=s("code"),qe=i("rel-events"),We=i("?"),De=r(),Re=s("p"),Me=s("code"),Be=i("rel-events"),Ne=i("\n    is a React Events Library that takes the concept of events, present in\n    redux, to a higher level of abstraction. It's a thin layer over redux that\n    enables you to stop thinking about actions, reducers, stores and\n    middlewares, so you can focus on what needs to be done: executing domain\n    logic reactively when events pop up."),Fe=r(),Ge=s("p"),Ke=i("To do that, let's imagine a simple scenario: we need to enable a user to log\n    into our app."),ze=r(),Ue=s("p"),Ye=i("You could do the whole request flow inside your components, but\n    "),Je=s("a"),Qe=i("as\n      we stated on our previous blog post"),Ve=i(", we don't really recommend doing\n    that - it always ends up messy. We could use redux, but then our junior\n    developers would need to pass that\n    "),Xe=s("code"),Ze=i("mapStateToProps"),_e=i("\n    hurdle, and sometimes we don't have the luxury of taking our time. We could\n    use sagas, but then redux is back with a vengeance."),et=r(),tt=s("p"),nt=i("Now, forget about actions and reducers and imagine we have an object called\n    LoginEvent. Whenever we call it passing an email and password, things get\n    done and data comes through to the component. Imagine you don't need to know\n    anything but its name. No reducers, no actions, no\n    "),at=s("code"),ot=i("connect"),rt=i("\n    or\n    "),st=s("code"),it=i("mapStateToProps"),ht=i(". It would be something like this:"),lt=r(),o(ct.$$.fragment),dt=r(),ut=s("p"),mt=i("Cool, but what about the whole behavior? Where's the logic to make the\n    request? How to deal with bad requests? Let's say, besides the Event, we\n    have something that manages the event flow, an Event Manager:"),gt=r(),o(ft.$$.fragment),pt=r(),vt=s("p"),wt=i("That's better. But how is this manager implemented? Because, if it needs to\n    deal with the event flow, it needs to do a lot of stuff: know how to make\n    the request and what to do when the request succeeds or fails. Oh, and we\n    need an intermediary state, because we love loading spinners! Hell, I forgot\n    about the inital state of the event as well! Ok, ok, let's see:"),bt=r(),o(yt.$$.fragment),Et=r(),kt=s("p"),xt=i("That's about it, right? But, hey, how do we trigger it? And how do I make\n    the Event register which Components are able to trigger it? How does the\n    component get the data from it? We're almost there:"),It=r(),o($t.$$.fragment),Tt=r(),Pt=s("p"),Lt=i("And that's exactly the current API for a HTTPEvent from\n    "),Ct=s("code"),At=i("rel-events"),Ht=i(". No actions, no reducers, no coupling between the\n    logic and the component layers, nothing. Of course, it needs some\n    configuration to hook it up with redux, but it's mostly a one time setup,\n    very well documented\n    "),Ot=s("a"),St=i("in our\n      docs"),jt=i("."),qt=r(),Wt=s("h2"),Dt=i("That sounds... nice! But what about features? I want features!"),Rt=r(),Mt=s("p"),Bt=i("With our current beta version (0.1.3 as of September 2019), you're able to:"),Nt=r(),Ft=s("ul"),Gt=s("li"),Kt=i("use a basic Event type (for the times you don't need to make HTTP\n      requests);"),zt=r(),Ut=s("li"),Yt=i("chain Events/HTTPEvents (useful for fetching more data when a request is\n      done);"),Jt=r(),Qt=s("li"),Vt=i("have multiple Events registering to the same Component (you'll probably\n      have a Component that needs to listen to multiple Events);"),Xt=r(),Zt=s("li"),_t=i("execute code after dispatching an Event (with\n      "),en=s("code"),tn=i("afterDispatch"),nn=i(");"),an=r(),on=s("li"),rn=i("execute code after a request is successful (with\n      "),sn=s("code"),hn=i("afterSuccess"),ln=i(");"),cn=r(),dn=s("li"),un=i("execute code after a request has failed (with\n      "),mn=s("code"),gn=i("afterFailure"),fn=i(");"),pn=r(),vn=s("li"),wn=i("evaluate if an event should be dispatched or not (with the\n      "),bn=s("code"),yn=i("shouldDispatch"),En=i("\n      method)."),kn=r(),xn=s("p"),In=i("And more! All that without the cognitive burden, the crazy constants, the\n    store names and all the bad developer experience from redux. The best part:\n    no huge learning curve. This post has basically all you need to know to use\n    our lib. Really."),$n=r(),Tn=s("p"),Pn=i("So if you liked it,\n    "),Ln=s("a"),Cn=i("take a look at our github\n      repo"),An=i("\n    to get started and share the love! Thanks for your attention, and see you\n    next time!"),this.h()},l(e){const a=h('[data-svelte="svelte-1by3gqx"]',document.head);l(t.$$.fragment,a),a.forEach(c),n=d(e),k=u(e,"H1",{});var o=m(k);L=u(o,"MARK",{});var r=m(L);C=g(r,"Keeping global state management sane with rel-events"),r.forEach(c),o.forEach(c),A=d(e),l(H.$$.fragment,e),O=d(e),S=u(e,"FIGURE",{});var s=m(S);j=u(s,"IMG",{src:!0,alt:!0}),s.forEach(c),W=d(e),D=u(e,"ARTICLE",{});var i=m(D);R=u(i,"P",{});var f=m(R);M=g(f,"Maintaining a big and complex react app is not for amateurs. Whatever you\n    may choose to manage your app state, chances are that it's hard to pick up,\n    like redux, or really convoluted, like making yourself a service layer. With\n    the goal of making it easy for new developers to jump into our projects, we\n    at Labcodes decided it was time to give this problem a little more thought.\n    Our answer was\n    "),B=u(f,"A",{href:!0});var p=m(B);N=g(p,"rel-events"),p.forEach(c),F=g(f,"."),f.forEach(c),G=d(i),K=u(i,"H2",{});var v=m(K);z=g(v,"Why another library to manage states?"),v.forEach(c),U=d(i),Y=u(i,"P",{});var w=m(Y);J=u(w,"A",{href:!0});var b=m(J);Q=u(b,"IMG",{src:!0,alt:!0}),b.forEach(c),w.forEach(c),X=d(i),Z=u(i,"P",{});var y=m(Z);_=g(y,"Whenever I think of making something new and shiny, this xkcd strip comes to\n    haunt me. Believe me, I don't want to be the kind of person that does\n    everything themselves, and that's one of my grievances with the fork\n    mentality. However, it was about time I did something to address a pesky\n    problem I deal with daily: using whatever library to separate business logic\n    from react components."),y.forEach(c),ee=d(i),te=u(i,"P",{});var E=m(te);ne=g(E,"At the end of the day, after much thought, I always end up surrendering and\n    running\n    "),ae=u(E,"CODE",{});var x=m(ae);oe=g(x,"npm install redux react-redux --save"),x.forEach(c),re=g(E,". I even shared my basic\n    tools to deal with redux on our\n    "),se=u(E,"A",{href:!0});var I=m(se);ie=u(I,"CODE",{});var $=m(ie);he=g($,"react-redux-api-tools"),$.forEach(c),I.forEach(c),le=g(E,"\n    package."),E.forEach(c),ce=d(i),de=u(i,"P",{});var T=m(de);ue=g(T,"And by no means I hate redux; in fact, I love it. It gets the job done, it's\n    ultra flexible, with low side effects. But let's be frank here: the\n    discomfort of reading\n    "),me=u(T,"CODE",{});var P=m(me);ge=g(P,"mapStateToProps"),P.forEach(c),fe=g(T,"\n    for the first time is\n    "),pe=u(T,"STRONG",{});var q=m(pe);ve=g(q,"real"),q.forEach(c),we=g(T,". It took me a long while to properly understand what\n    was going on. Then there are actions, action creators, reducers, dispatches\n    and middlewares, and sagas, and async dispatches; it's neverending."),T.forEach(c),be=d(i),ye=u(i,"P",{});var V=m(ye);Ee=g(V,"After those confusing and long first months, things started to get easier,\n    but way,\n    "),ke=u(V,"STRONG",{});var Hn=m(ke);xe=g(Hn,"way"),Hn.forEach(c),Ie=g(V,"\n    too verbose. I always thought that redux felt a lower level tool, and that I\n    was always in need of specifying, step by step, exactly and strictly what\n    and how things should be done. No abstraction at all. A lot of copy and\n    paste, though."),V.forEach(c),$e=d(i),Te=u(i,"P",{});var On=m(Te);Pe=g(On,"I came to the conclusion that it would be nice to have all the features I\n    would like in my redux configuration - a proper HTTP request flow, less\n    repetition, meaningful connection between actions and reducers -, without\n    sacrificing anything. I got the green light to develop internally a solution\n    for that:\n    "),Le=u(On,"CODE",{});var Sn=m(Le);Ce=g(Sn,"rel-events"),Sn.forEach(c),Ae=g(On,"."),On.forEach(c),He=d(i),Oe=u(i,"H2",{});var jn=m(Oe);Se=g(jn,"Cool, but what's "),je=u(jn,"CODE",{});var qn=m(je);qe=g(qn,"rel-events"),qn.forEach(c),We=g(jn,"?"),jn.forEach(c),De=d(i),Re=u(i,"P",{});var Wn=m(Re);Me=u(Wn,"CODE",{});var Dn=m(Me);Be=g(Dn,"rel-events"),Dn.forEach(c),Ne=g(Wn,"\n    is a React Events Library that takes the concept of events, present in\n    redux, to a higher level of abstraction. It's a thin layer over redux that\n    enables you to stop thinking about actions, reducers, stores and\n    middlewares, so you can focus on what needs to be done: executing domain\n    logic reactively when events pop up."),Wn.forEach(c),Fe=d(i),Ge=u(i,"P",{});var Rn=m(Ge);Ke=g(Rn,"To do that, let's imagine a simple scenario: we need to enable a user to log\n    into our app."),Rn.forEach(c),ze=d(i),Ue=u(i,"P",{});var Mn=m(Ue);Ye=g(Mn,"You could do the whole request flow inside your components, but\n    "),Je=u(Mn,"A",{href:!0});var Bn=m(Je);Qe=g(Bn,"as\n      we stated on our previous blog post"),Bn.forEach(c),Ve=g(Mn,", we don't really recommend doing\n    that - it always ends up messy. We could use redux, but then our junior\n    developers would need to pass that\n    "),Xe=u(Mn,"CODE",{});var Nn=m(Xe);Ze=g(Nn,"mapStateToProps"),Nn.forEach(c),_e=g(Mn,"\n    hurdle, and sometimes we don't have the luxury of taking our time. We could\n    use sagas, but then redux is back with a vengeance."),Mn.forEach(c),et=d(i),tt=u(i,"P",{});var Fn=m(tt);nt=g(Fn,"Now, forget about actions and reducers and imagine we have an object called\n    LoginEvent. Whenever we call it passing an email and password, things get\n    done and data comes through to the component. Imagine you don't need to know\n    anything but its name. No reducers, no actions, no\n    "),at=u(Fn,"CODE",{});var Gn=m(at);ot=g(Gn,"connect"),Gn.forEach(c),rt=g(Fn,"\n    or\n    "),st=u(Fn,"CODE",{});var Kn=m(st);it=g(Kn,"mapStateToProps"),Kn.forEach(c),ht=g(Fn,". It would be something like this:"),Fn.forEach(c),lt=d(i),l(ct.$$.fragment,i),dt=d(i),ut=u(i,"P",{});var zn=m(ut);mt=g(zn,"Cool, but what about the whole behavior? Where's the logic to make the\n    request? How to deal with bad requests? Let's say, besides the Event, we\n    have something that manages the event flow, an Event Manager:"),zn.forEach(c),gt=d(i),l(ft.$$.fragment,i),pt=d(i),vt=u(i,"P",{});var Un=m(vt);wt=g(Un,"That's better. But how is this manager implemented? Because, if it needs to\n    deal with the event flow, it needs to do a lot of stuff: know how to make\n    the request and what to do when the request succeeds or fails. Oh, and we\n    need an intermediary state, because we love loading spinners! Hell, I forgot\n    about the inital state of the event as well! Ok, ok, let's see:"),Un.forEach(c),bt=d(i),l(yt.$$.fragment,i),Et=d(i),kt=u(i,"P",{});var Yn=m(kt);xt=g(Yn,"That's about it, right? But, hey, how do we trigger it? And how do I make\n    the Event register which Components are able to trigger it? How does the\n    component get the data from it? We're almost there:"),Yn.forEach(c),It=d(i),l($t.$$.fragment,i),Tt=d(i),Pt=u(i,"P",{});var Jn=m(Pt);Lt=g(Jn,"And that's exactly the current API for a HTTPEvent from\n    "),Ct=u(Jn,"CODE",{});var Qn=m(Ct);At=g(Qn,"rel-events"),Qn.forEach(c),Ht=g(Jn,". No actions, no reducers, no coupling between the\n    logic and the component layers, nothing. Of course, it needs some\n    configuration to hook it up with redux, but it's mostly a one time setup,\n    very well documented\n    "),Ot=u(Jn,"A",{href:!0});var Vn=m(Ot);St=g(Vn,"in our\n      docs"),Vn.forEach(c),jt=g(Jn,"."),Jn.forEach(c),qt=d(i),Wt=u(i,"H2",{});var Xn=m(Wt);Dt=g(Xn,"That sounds... nice! But what about features? I want features!"),Xn.forEach(c),Rt=d(i),Mt=u(i,"P",{});var Zn=m(Mt);Bt=g(Zn,"With our current beta version (0.1.3 as of September 2019), you're able to:"),Zn.forEach(c),Nt=d(i),Ft=u(i,"UL",{});var _n=m(Ft);Gt=u(_n,"LI",{});var ea=m(Gt);Kt=g(ea,"use a basic Event type (for the times you don't need to make HTTP\n      requests);"),ea.forEach(c),zt=d(_n),Ut=u(_n,"LI",{});var ta=m(Ut);Yt=g(ta,"chain Events/HTTPEvents (useful for fetching more data when a request is\n      done);"),ta.forEach(c),Jt=d(_n),Qt=u(_n,"LI",{});var na=m(Qt);Vt=g(na,"have multiple Events registering to the same Component (you'll probably\n      have a Component that needs to listen to multiple Events);"),na.forEach(c),Xt=d(_n),Zt=u(_n,"LI",{});var aa=m(Zt);_t=g(aa,"execute code after dispatching an Event (with\n      "),en=u(aa,"CODE",{});var oa=m(en);tn=g(oa,"afterDispatch"),oa.forEach(c),nn=g(aa,");"),aa.forEach(c),an=d(_n),on=u(_n,"LI",{});var ra=m(on);rn=g(ra,"execute code after a request is successful (with\n      "),sn=u(ra,"CODE",{});var sa=m(sn);hn=g(sa,"afterSuccess"),sa.forEach(c),ln=g(ra,");"),ra.forEach(c),cn=d(_n),dn=u(_n,"LI",{});var ia=m(dn);un=g(ia,"execute code after a request has failed (with\n      "),mn=u(ia,"CODE",{});var ha=m(mn);gn=g(ha,"afterFailure"),ha.forEach(c),fn=g(ia,");"),ia.forEach(c),pn=d(_n),vn=u(_n,"LI",{});var la=m(vn);wn=g(la,"evaluate if an event should be dispatched or not (with the\n      "),bn=u(la,"CODE",{});var ca=m(bn);yn=g(ca,"shouldDispatch"),ca.forEach(c),En=g(la,"\n      method)."),la.forEach(c),_n.forEach(c),kn=d(i),xn=u(i,"P",{});var da=m(xn);In=g(da,"And more! All that without the cognitive burden, the crazy constants, the\n    store names and all the bad developer experience from redux. The best part:\n    no huge learning curve. This post has basically all you need to know to use\n    our lib. Really."),da.forEach(c),$n=d(i),Tn=u(i,"P",{});var ua=m(Tn);Pn=g(ua,"So if you liked it,\n    "),Ln=u(ua,"A",{href:!0});var ma=m(Ln);Cn=g(ma,"take a look at our github\n      repo"),ma.forEach(c),An=g(ua,"\n    to get started and share the love! Thanks for your attention, and see you\n    next time!"),ua.forEach(c),i.forEach(c),this.h()},h(){j.src!==(q=P)&&f(j,"src",q),f(j,"alt","Logos from React and Redux"),f(B,"href","https://github.com/labcodes/rel-events"),Q.src!==(V="https://imgs.xkcd.com/comics/standards.png")&&f(Q,"src","https://imgs.xkcd.com/comics/standards.png"),f(Q,"alt","xkcd is always right"),f(J,"href","https://xkcd.com/927/"),f(se,"href","https://github.com/labcodes/react-redux-api-tools/"),f(Je,"href","https://labcodes.com.br/blog/en/decoupling-logic-from-react-components.html"),f(Ot,"href","https://github.com/labcodes/rel-events/tree/master/docs"),f(Ln,"href","https://github.com/labcodes/rel-events")},m(a,o){p(t,document.head,null),v(a,n,o),v(a,k,o),w(k,L),w(L,C),v(a,A,o),p(H,a,o),v(a,O,o),v(a,S,o),w(S,j),v(a,W,o),v(a,D,o),w(D,R),w(R,M),w(R,B),w(B,N),w(R,F),w(D,G),w(D,K),w(K,z),w(D,U),w(D,Y),w(Y,J),w(J,Q),w(D,X),w(D,Z),w(Z,_),w(D,ee),w(D,te),w(te,ne),w(te,ae),w(ae,oe),w(te,re),w(te,se),w(se,ie),w(ie,he),w(te,le),w(D,ce),w(D,de),w(de,ue),w(de,me),w(me,ge),w(de,fe),w(de,pe),w(pe,ve),w(de,we),w(D,be),w(D,ye),w(ye,Ee),w(ye,ke),w(ke,xe),w(ye,Ie),w(D,$e),w(D,Te),w(Te,Pe),w(Te,Le),w(Le,Ce),w(Te,Ae),w(D,He),w(D,Oe),w(Oe,Se),w(Oe,je),w(je,qe),w(Oe,We),w(D,De),w(D,Re),w(Re,Me),w(Me,Be),w(Re,Ne),w(D,Fe),w(D,Ge),w(Ge,Ke),w(D,ze),w(D,Ue),w(Ue,Ye),w(Ue,Je),w(Je,Qe),w(Ue,Ve),w(Ue,Xe),w(Xe,Ze),w(Ue,_e),w(D,et),w(D,tt),w(tt,nt),w(tt,at),w(at,ot),w(tt,rt),w(tt,st),w(st,it),w(tt,ht),w(D,lt),p(ct,D,null),w(D,dt),w(D,ut),w(ut,mt),w(D,gt),p(ft,D,null),w(D,pt),w(D,vt),w(vt,wt),w(D,bt),p(yt,D,null),w(D,Et),w(D,kt),w(kt,xt),w(D,It),p($t,D,null),w(D,Tt),w(D,Pt),w(Pt,Lt),w(Pt,Ct),w(Ct,At),w(Pt,Ht),w(Pt,Ot),w(Ot,St),w(Pt,jt),w(D,qt),w(D,Wt),w(Wt,Dt),w(D,Rt),w(D,Mt),w(Mt,Bt),w(D,Nt),w(D,Ft),w(Ft,Gt),w(Gt,Kt),w(Ft,zt),w(Ft,Ut),w(Ut,Yt),w(Ft,Jt),w(Ft,Qt),w(Qt,Vt),w(Ft,Xt),w(Ft,Zt),w(Zt,_t),w(Zt,en),w(en,tn),w(Zt,nn),w(Ft,an),w(Ft,on),w(on,rn),w(on,sn),w(sn,hn),w(on,ln),w(Ft,cn),w(Ft,dn),w(dn,un),w(dn,mn),w(mn,gn),w(dn,fn),w(Ft,pn),w(Ft,vn),w(vn,wn),w(vn,bn),w(bn,yn),w(vn,En),w(D,kn),w(D,xn),w(xn,In),w(D,$n),w(D,Tn),w(Tn,Pn),w(Tn,Ln),w(Ln,Cn),w(Tn,An),e[2](D),Hn=!0},p(e,[t]){const n={};2&t&&(n.text=e[1]),H.$set(n)},i(e){Hn||(b(t.$$.fragment,e),b(H.$$.fragment,e),b(ct.$$.fragment,e),b(ft.$$.fragment,e),b(yt.$$.fragment,e),b($t.$$.fragment,e),Hn=!0)},o(e){y(t.$$.fragment,e),y(H.$$.fragment,e),y(ct.$$.fragment,e),y(ft.$$.fragment,e),y(yt.$$.fragment,e),y($t.$$.fragment,e),Hn=!1},d(a){E(t),a&&c(n),a&&c(k),a&&c(A),E(H,a),a&&c(O),a&&c(S),a&&c(W),a&&c(D),E(ct),E(ft),E(yt),E($t),e[2](null)}}}function C(e,t,n){let a,o;return e.$$.update=()=>{1&e.$$.dirty&&n(1,o=a&&a.textContent)},[a,o,function(e){k[e?"unshift":"push"]((()=>{a=e,n(0,a)}))}]}export default class extends e{constructor(e){super(),t(this,e,C,L,n,{})}}
