import{S as e,i as a,s as o,E as s,w as r,F as n,G as i,c as d,e as c,x as t,d as m,H as u,k as p,I as l,g as v,n as f}from"./client.ba4c128a.js";import{c as g,i as h,a as q,b as E,d as b,e as x,f as R,g as S,h as G}from"./image8.948aeaf3.js";function I(e){let a,o,I,O,P,z,w,A,N,j,k,T,M,F,D,U,C,H,B,J,V,L,Q,y,K,W,X,Y,Z,$,_,ee,ae,oe,se,re,ne,ie,de,ce,te,me,ue,pe,le,ve,fe,ge,he,qe,Ee,be,xe,Re,Se,Ge,Ie,Oe,Pe,ze,we,Ae,Ne,je,ke,Te,Me,Fe,De,Ue,Ce,He,Be,Je,Ve,Le,Qe,ye,Ke,We,Xe,Ye,Ze,$e,_e,ea,aa,oa,sa,ra,na,ia,da,ca,ta,ma,ua,pa,la,va,fa,ga,ha,qa,Ea,ba,xa,Ra,Sa,Ga,Ia,Oa,Pa,za,wa,Aa,Na,ja,ka,Ta,Ma,Fa,Da,Ua,Ca,Ha,Ba,Ja,Va,La,Qa,ya,Ka,Wa,Xa,Ya,Za,$a,_a,eo,ao,oo,so,ro,no,io,co,to,mo,uo,po,lo,vo,fo,go,ho,qo,Eo,bo,xo,Ro,So,Go,Io,Oo,Po,zo,wo,Ao,No,jo,ko,To,Mo,Fo,Do,Uo,Co,Ho,Bo,Jo,Vo,Lo,Qo,yo;return{c(){a=s("meta"),o=s("meta"),I=r(),O=s("h1"),P=s("mark"),z=n("Desacoplando a lógica de componentes React"),w=r(),A=s("p"),N=n("2019-7-23"),j=r(),k=s("figure"),T=s("img"),F=r(),D=s("p"),U=s("em"),C=n("for native english speakers,\n    "),H=s("a"),B=n("here's the translated\n      post"),J=r(),V=s("p"),L=n("Sempre que há um novo projeto baseado em React, grande parte dos devs frontend\n  irão passar pelo ritual de configuração inicial. Padrões de implementação de\n  estilos, desacoplamento de componentes e estrutura de diretórios irão emergir\n  -\n  "),Q=s("strong"),y=n("nem sempre pro bem"),K=n(". O pior é que todo dev frontend que eu já\n  vi irá resolver o maior problema de todos, o problema de desacoplar lógica de\n  negócio, de uma forma diferente. Em um esforço para criar uma padronização e\n  resolver a questão da camada de domínio aqui na Labcodes, eu pesquisei um\n  bocado e achei uma forma boa e sustentável para lidar com requisições e\n  processamento de dados. O resultado: react-redux-api-tools."),W=r(),X=s("h2"),Y=n("Vamos imaginar um cenário comum: CRUD"),Z=r(),$=s("p"),_=n("Já que o javascript é muito permissivo, há inúmeras maneiras de implementarmos\n  um CRUD em uma SPA. Se limitarmos o escopo ao uso do react, as coisas ficam\n  mais fáceis, mas ainda há possíveis implementações demais. Uma delas é de usar\n  os hooks de ciclo de vida para fazer as requisições. Seu código provavelmente\n  irá ficar parecido com isso:"),ee=r(),ae=s("figure"),oe=s("img"),re=r(),ne=s("p"),ie=n("Eu acho que não preciso falar muito sobre isso, mas vou falar de qualquer\n  forma: essa implementação, mesmo sendo perfeitamente válida, tem alguns\n  "),de=s("strong"),ce=n("grandes"),te=n("\n  problemas."),me=r(),ue=s("p"),pe=n("1.A requisição está sendo feita dentro do componente que, em teoria, deveria\n  ter apenas um trabalho:\n  "),le=s("strong"),ve=n("renderizar os dados"),fe=n(". Se, por exemplo, você precisasse limpar\n  a sessão do usuário ou executar qualquer lógica de negócio, ela provavelmente\n  estaria aqui, o que é\n  "),ge=s("strong"),he=n("ainda pior"),qe=n(";"),Ee=s("br"),be=n("\n  2. Os dados da resposta da requisição está vivendo dentro do estado do\n  componente, e isso significa que tudo será perdido assim que o componente\n  desmontar;"),xe=s("br"),Re=n("\n  3. Você terá\n  "),Se=s("strong"),Ge=n("sempre"),Ie=n("\n  que pegar os dados da API para cada instância do componente, mesmo que já\n  tenha feito essa específica requisição um bilhão de vezes;"),Oe=s("br"),Pe=n("\n  4. Não há nenhum estado intermediário entre o início da requisição e sua\n  resposta, então nada de spinners de loading (apesar de você poder implementar\n  essa lógica construindo um\n  "),ze=s("em"),we=n("callback hell"),Ae=n("\n  de setStates);"),Ne=s("br"),je=n("\n  5. Já que componentes react são hierárquicos, se você precisar desses dados\n  dentro de um componente filho ou pai, você terá que implementar\n  contextos/props e callbacks.\n  "),ke=s("strong"),Te=n("O código fica complicado. RAPIDINHO."),Me=s("br"),Fe=r(),De=s("p"),Ue=n("Para melhorar esse código, muitos de nós preferem usar uma biblioteca para\n  prover um estado mais global para a aplicação; um estado que vive fora de\n  todos os componentes."),Ce=r(),He=s("h2"),Be=n("Segundo passo: usando Redux"),Je=r(),Ve=s("p"),Le=n("Redux é uma das melhores bibliotecas para esse tipo de trabalho. Digamos que\n  você vai usar redux para lidar com dados e lógica de negócio. Assumindo que\n  você usará a camada de reducers para formatar dados e chamar lógicas de\n  domínio, seu componente vai ficar mais ou menos assim:"),Qe=r(),ye=s("figure"),Ke=s("img"),Xe=r(),Ye=s("p"),Ze=n("Isso resolve grande parte dos problemas, mas eu diria que essa solução acopla\n  ainda mais o código e, certeza, deixa ele mais difícil de ler e manter. A\n  causa raiz disso tudo é o fato de que o componente está sendo responsável por\n  absolutamente tudo: pegar os dados da API e orquestrar eventos do redux,\n  quando era para ele estar… renderizando coisas. O fluxo ideal para resolver\n  todos os problemas, pelo menos os mais importantes, seria algo similar a isso:"),$e=r(),_e=s("figure"),ea=s("img"),oa=r(),sa=s("p"),ra=n("Note que a única forma de completamente remover a lógica de negócio dos\n  componentes é acionando os casos de uso de ‘Sucesso’ e ‘Falha’\n  "),na=s("strong"),ia=n("fora do componente"),da=n(". Componentes devem renderizar coisas, não\n  lidar com gerenciamento de estado da\n  "),ca=s("strong"),ta=n("aplicação inteira"),ma=n(". Isso significa que o componente apenas\n  deve avisar a alguém que precisa de dados, disparando um evento (o evento de\n  ‘pega esses dados pra mim’), e então reagir aos dados quando eles estiverem\n  lá. Para respeitar essa ideia, nosso código do componente deveria ser tão\n  simples quanto isso:"),ua=r(),pa=s("figure"),la=s("img"),fa=r(),ga=s("p"),ha=n("E isso significa que… as actions devem fazer a requisição dos dados? E\n  reducers iriam disparar outras ações? Soa estranho, né? Porque é. E não é o\n  que eu estou sugerindo\n  "),qa=s("strong"),Ea=n("mesmo"),ba=n("."),xa=r(),Ra=s("h2"),Sa=n("Eis que chegam os middlewares"),Ga=r(),Ia=s("p"),Oa=n("Para entregarmos o fluxo ideal de dados,\n  "),Pa=s("strong"),za=n("middlewares do redux são maravilhosos"),wa=n(". Imaginem que queremos\n  que nosso componente seja exatamente como o código que vimos acima. Se nós,\n  por exemplo, tivéssemos algo entre as actions e os reducers, a gente\n  conseguiria fazer com que esse\n  "),Aa=s("em"),Na=n("código do meio"),ja=r(),ka=s("strong"),Ta=n("fizesse a requisição"),Ma=n("\n  e, dependendo do resultado,\n  "),Fa=s("strong"),Da=n("decidisse quais reducers disparar"),Ua=n(". Assim, deixaríamos o redux\n  livre para fazer seu trabalho de gerenciar o estado da aplicação e lidar com\n  eventos, enquanto os componentes focariam em renderizar coisas -\n  "),Ca=s("strong"),Ha=n("somente"),Ba=n("\n  renderizar coisas. Estou falando sobre algo como isso aqui:"),Ja=r(),Va=s("figure"),La=s("img"),ya=r(),Ka=s("p"),Wa=n("Com esse fluxo proposto, nossas actions poderiam ser mais ou menos assim:"),Xa=r(),Ya=s("figure"),Za=s("img"),_a=r(),eo=s("p"),ao=n("Ok, vamos com calma. O que você está vendo aí em cima é a nossa convenção\n  atual que descreve uma\n  "),oo=s("em"),so=n("action de requisição"),ro=n(", que usa o middleware incluído no nosso pacote\n  npm\n  "),no=s("code"),io=n("[react-redux-api-tools](https://www.npmjs.com/package/react-redux-api-tools)"),co=n(".\n  Fazer o dispatch dessa action\n  "),to=s("strong"),mo=n("configura"),uo=n("\n  o middleware para\n  "),po=s("strong"),lo=n("fazer a requisição"),vo=n("\n  (ao chamar a\n  "),fo=s("code"),go=n("apiCallFunction"),ho=n(") e para\n  "),qo=s("strong"),Eo=n("usar o reducer correto"),bo=n("\n  assim que a requisição estiver concluída. Enquanto isso, nossos componentes e\n  reducers se manteriam inalterados:"),xo=r(),Ro=s("figure"),So=s("img"),Io=r(),Oo=s("figure"),Po=s("img"),wo=r(),Ao=s("p"),No=n("E "),jo=s("em"),ko=n("voilá,"),To=n(" nosso fluxo está bem mais limpo, simples e desacoplado!"),Mo=r(),Fo=s("h2"),Do=n("Se você gostou disso ou isso parece mágico demais…"),Uo=r(),Co=s("p"),Ho=n("Gostou na API desse middleware? Quer desenvolver seus projetos react-redux\n  dessa maneira? Está curiosa para saber como tudo isso funciona por baixo dos\n  panos? Então você é uma pessoa que poderia usar e contribuir com nosso pacote\n  npm\n  "),Bo=s("a"),Jo=n("react-redux-api-tools"),Vo=n(".\n  Reportagem de bugs e sugestões de features são bem vindas! E isso tudo é só o\n  começo;\n  "),Lo=s("a"),Qo=n("react-redux-api-tools"),yo=n("\n  traz um monte de outras features que não consegui descrever nesse post. Dê uma\n  boa olhada na nossa documentação para descobrir como melhorar e simplificar\n  seu código usando nossas ferramentas! Obrigado, e até a próxima!"),this.h()},l(e){const s=i('[data-svelte="svelte-clatcc"]',document.head);a=d(s,"META",{name:!0,content:!0}),o=d(s,"META",{name:!0,content:!0}),s.forEach(c),I=t(e),O=d(e,"H1",{});var r=m(O);P=d(r,"MARK",{});var n=m(P);z=u(n,"Desacoplando a lógica de componentes React"),n.forEach(c),r.forEach(c),w=t(e),A=d(e,"P",{class:!0});var p=m(A);N=u(p,"2019-7-23"),p.forEach(c),j=t(e),k=d(e,"FIGURE",{});var l=m(k);T=d(l,"IMG",{src:!0,alt:!0}),l.forEach(c),F=t(e),D=d(e,"P",{});var v=m(D);U=d(v,"EM",{});var f=m(U);C=u(f,"for native english speakers,\n    "),H=d(f,"A",{href:!0});var g=m(H);B=u(g,"here's the translated\n      post"),g.forEach(c),f.forEach(c),v.forEach(c),J=t(e),V=d(e,"P",{});var h=m(V);L=u(h,"Sempre que há um novo projeto baseado em React, grande parte dos devs frontend\n  irão passar pelo ritual de configuração inicial. Padrões de implementação de\n  estilos, desacoplamento de componentes e estrutura de diretórios irão emergir\n  -\n  "),Q=d(h,"STRONG",{});var q=m(Q);y=u(q,"nem sempre pro bem"),q.forEach(c),K=u(h,". O pior é que todo dev frontend que eu já\n  vi irá resolver o maior problema de todos, o problema de desacoplar lógica de\n  negócio, de uma forma diferente. Em um esforço para criar uma padronização e\n  resolver a questão da camada de domínio aqui na Labcodes, eu pesquisei um\n  bocado e achei uma forma boa e sustentável para lidar com requisições e\n  processamento de dados. O resultado: react-redux-api-tools."),h.forEach(c),W=t(e),X=d(e,"H2",{});var E=m(X);Y=u(E,"Vamos imaginar um cenário comum: CRUD"),E.forEach(c),Z=t(e),$=d(e,"P",{});var b=m($);_=u(b,"Já que o javascript é muito permissivo, há inúmeras maneiras de implementarmos\n  um CRUD em uma SPA. Se limitarmos o escopo ao uso do react, as coisas ficam\n  mais fáceis, mas ainda há possíveis implementações demais. Uma delas é de usar\n  os hooks de ciclo de vida para fazer as requisições. Seu código provavelmente\n  irá ficar parecido com isso:"),b.forEach(c),ee=t(e),ae=d(e,"FIGURE",{});var x=m(ae);oe=d(x,"IMG",{alt:!0,src:!0}),x.forEach(c),re=t(e),ne=d(e,"P",{});var R=m(ne);ie=u(R,"Eu acho que não preciso falar muito sobre isso, mas vou falar de qualquer\n  forma: essa implementação, mesmo sendo perfeitamente válida, tem alguns\n  "),de=d(R,"STRONG",{});var S=m(de);ce=u(S,"grandes"),S.forEach(c),te=u(R,"\n  problemas."),R.forEach(c),me=t(e),ue=d(e,"P",{});var G=m(ue);pe=u(G,"1.A requisição está sendo feita dentro do componente que, em teoria, deveria\n  ter apenas um trabalho:\n  "),le=d(G,"STRONG",{});var M=m(le);ve=u(M,"renderizar os dados"),M.forEach(c),fe=u(G,". Se, por exemplo, você precisasse limpar\n  a sessão do usuário ou executar qualquer lógica de negócio, ela provavelmente\n  estaria aqui, o que é\n  "),ge=d(G,"STRONG",{});var se=m(ge);he=u(se,"ainda pior"),se.forEach(c),qe=u(G,";"),Ee=d(G,"BR",{}),be=u(G,"\n  2. Os dados da resposta da requisição está vivendo dentro do estado do\n  componente, e isso significa que tudo será perdido assim que o componente\n  desmontar;"),xe=d(G,"BR",{}),Re=u(G,"\n  3. Você terá\n  "),Se=d(G,"STRONG",{});var We=m(Se);Ge=u(We,"sempre"),We.forEach(c),Ie=u(G,"\n  que pegar os dados da API para cada instância do componente, mesmo que já\n  tenha feito essa específica requisição um bilhão de vezes;"),Oe=d(G,"BR",{}),Pe=u(G,"\n  4. Não há nenhum estado intermediário entre o início da requisição e sua\n  resposta, então nada de spinners de loading (apesar de você poder implementar\n  essa lógica construindo um\n  "),ze=d(G,"EM",{});var aa=m(ze);we=u(aa,"callback hell"),aa.forEach(c),Ae=u(G,"\n  de setStates);"),Ne=d(G,"BR",{}),je=u(G,"\n  5. Já que componentes react são hierárquicos, se você precisar desses dados\n  dentro de um componente filho ou pai, você terá que implementar\n  contextos/props e callbacks.\n  "),ke=d(G,"STRONG",{});var va=m(ke);Te=u(va,"O código fica complicado. RAPIDINHO."),va.forEach(c),Me=d(G,"BR",{}),G.forEach(c),Fe=t(e),De=d(e,"P",{});var Qa=m(De);Ue=u(Qa,"Para melhorar esse código, muitos de nós preferem usar uma biblioteca para\n  prover um estado mais global para a aplicação; um estado que vive fora de\n  todos os componentes."),Qa.forEach(c),Ce=t(e),He=d(e,"H2",{});var $a=m(He);Be=u($a,"Segundo passo: usando Redux"),$a.forEach(c),Je=t(e),Ve=d(e,"P",{});var Go=m(Ve);Le=u(Go,"Redux é uma das melhores bibliotecas para esse tipo de trabalho. Digamos que\n  você vai usar redux para lidar com dados e lógica de negócio. Assumindo que\n  você usará a camada de reducers para formatar dados e chamar lógicas de\n  domínio, seu componente vai ficar mais ou menos assim:"),Go.forEach(c),Qe=t(e),ye=d(e,"FIGURE",{});var zo=m(ye);Ke=d(zo,"IMG",{alt:!0,src:!0}),zo.forEach(c),Xe=t(e),Ye=d(e,"P",{});var Ko=m(Ye);Ze=u(Ko,"Isso resolve grande parte dos problemas, mas eu diria que essa solução acopla\n  ainda mais o código e, certeza, deixa ele mais difícil de ler e manter. A\n  causa raiz disso tudo é o fato de que o componente está sendo responsável por\n  absolutamente tudo: pegar os dados da API e orquestrar eventos do redux,\n  quando era para ele estar… renderizando coisas. O fluxo ideal para resolver\n  todos os problemas, pelo menos os mais importantes, seria algo similar a isso:"),Ko.forEach(c),$e=t(e),_e=d(e,"FIGURE",{});var Wo=m(_e);ea=d(Wo,"IMG",{alt:!0,src:!0}),Wo.forEach(c),oa=t(e),sa=d(e,"P",{});var Xo=m(sa);ra=u(Xo,"Note que a única forma de completamente remover a lógica de negócio dos\n  componentes é acionando os casos de uso de ‘Sucesso’ e ‘Falha’\n  "),na=d(Xo,"STRONG",{});var Yo=m(na);ia=u(Yo,"fora do componente"),Yo.forEach(c),da=u(Xo,". Componentes devem renderizar coisas, não\n  lidar com gerenciamento de estado da\n  "),ca=d(Xo,"STRONG",{});var Zo=m(ca);ta=u(Zo,"aplicação inteira"),Zo.forEach(c),ma=u(Xo,". Isso significa que o componente apenas\n  deve avisar a alguém que precisa de dados, disparando um evento (o evento de\n  ‘pega esses dados pra mim’), e então reagir aos dados quando eles estiverem\n  lá. Para respeitar essa ideia, nosso código do componente deveria ser tão\n  simples quanto isso:"),Xo.forEach(c),ua=t(e),pa=d(e,"FIGURE",{});var $o=m(pa);la=d($o,"IMG",{alt:!0,src:!0}),$o.forEach(c),fa=t(e),ga=d(e,"P",{});var _o=m(ga);ha=u(_o,"E isso significa que… as actions devem fazer a requisição dos dados? E\n  reducers iriam disparar outras ações? Soa estranho, né? Porque é. E não é o\n  que eu estou sugerindo\n  "),qa=d(_o,"STRONG",{});var es=m(qa);Ea=u(es,"mesmo"),es.forEach(c),ba=u(_o,"."),_o.forEach(c),xa=t(e),Ra=d(e,"H2",{});var as=m(Ra);Sa=u(as,"Eis que chegam os middlewares"),as.forEach(c),Ga=t(e),Ia=d(e,"P",{});var os=m(Ia);Oa=u(os,"Para entregarmos o fluxo ideal de dados,\n  "),Pa=d(os,"STRONG",{});var ss=m(Pa);za=u(ss,"middlewares do redux são maravilhosos"),ss.forEach(c),wa=u(os,". Imaginem que queremos\n  que nosso componente seja exatamente como o código que vimos acima. Se nós,\n  por exemplo, tivéssemos algo entre as actions e os reducers, a gente\n  conseguiria fazer com que esse\n  "),Aa=d(os,"EM",{});var rs=m(Aa);Na=u(rs,"código do meio"),rs.forEach(c),ja=t(os),ka=d(os,"STRONG",{});var ns=m(ka);Ta=u(ns,"fizesse a requisição"),ns.forEach(c),Ma=u(os,"\n  e, dependendo do resultado,\n  "),Fa=d(os,"STRONG",{});var is=m(Fa);Da=u(is,"decidisse quais reducers disparar"),is.forEach(c),Ua=u(os,". Assim, deixaríamos o redux\n  livre para fazer seu trabalho de gerenciar o estado da aplicação e lidar com\n  eventos, enquanto os componentes focariam em renderizar coisas -\n  "),Ca=d(os,"STRONG",{});var ds=m(Ca);Ha=u(ds,"somente"),ds.forEach(c),Ba=u(os,"\n  renderizar coisas. Estou falando sobre algo como isso aqui:"),os.forEach(c),Ja=t(e),Va=d(e,"FIGURE",{});var cs=m(Va);La=d(cs,"IMG",{alt:!0,src:!0}),cs.forEach(c),ya=t(e),Ka=d(e,"P",{});var ts=m(Ka);Wa=u(ts,"Com esse fluxo proposto, nossas actions poderiam ser mais ou menos assim:"),ts.forEach(c),Xa=t(e),Ya=d(e,"FIGURE",{});var ms=m(Ya);Za=d(ms,"IMG",{alt:!0,src:!0}),ms.forEach(c),_a=t(e),eo=d(e,"P",{});var us=m(eo);ao=u(us,"Ok, vamos com calma. O que você está vendo aí em cima é a nossa convenção\n  atual que descreve uma\n  "),oo=d(us,"EM",{});var ps=m(oo);so=u(ps,"action de requisição"),ps.forEach(c),ro=u(us,", que usa o middleware incluído no nosso pacote\n  npm\n  "),no=d(us,"CODE",{});var ls=m(no);io=u(ls,"[react-redux-api-tools](https://www.npmjs.com/package/react-redux-api-tools)"),ls.forEach(c),co=u(us,".\n  Fazer o dispatch dessa action\n  "),to=d(us,"STRONG",{});var vs=m(to);mo=u(vs,"configura"),vs.forEach(c),uo=u(us,"\n  o middleware para\n  "),po=d(us,"STRONG",{});var fs=m(po);lo=u(fs,"fazer a requisição"),fs.forEach(c),vo=u(us,"\n  (ao chamar a\n  "),fo=d(us,"CODE",{});var gs=m(fo);go=u(gs,"apiCallFunction"),gs.forEach(c),ho=u(us,") e para\n  "),qo=d(us,"STRONG",{});var hs=m(qo);Eo=u(hs,"usar o reducer correto"),hs.forEach(c),bo=u(us,"\n  assim que a requisição estiver concluída. Enquanto isso, nossos componentes e\n  reducers se manteriam inalterados:"),us.forEach(c),xo=t(e),Ro=d(e,"FIGURE",{});var qs=m(Ro);So=d(qs,"IMG",{alt:!0,src:!0}),qs.forEach(c),Io=t(e),Oo=d(e,"FIGURE",{});var Es=m(Oo);Po=d(Es,"IMG",{alt:!0,src:!0}),Es.forEach(c),wo=t(e),Ao=d(e,"P",{});var bs=m(Ao);No=u(bs,"E "),jo=d(bs,"EM",{});var xs=m(jo);ko=u(xs,"voilá,"),xs.forEach(c),To=u(bs," nosso fluxo está bem mais limpo, simples e desacoplado!"),bs.forEach(c),Mo=t(e),Fo=d(e,"H2",{});var Rs=m(Fo);Do=u(Rs,"Se você gostou disso ou isso parece mágico demais…"),Rs.forEach(c),Uo=t(e),Co=d(e,"P",{});var Ss=m(Co);Ho=u(Ss,"Gostou na API desse middleware? Quer desenvolver seus projetos react-redux\n  dessa maneira? Está curiosa para saber como tudo isso funciona por baixo dos\n  panos? Então você é uma pessoa que poderia usar e contribuir com nosso pacote\n  npm\n  "),Bo=d(Ss,"A",{href:!0});var Gs=m(Bo);Jo=u(Gs,"react-redux-api-tools"),Gs.forEach(c),Vo=u(Ss,".\n  Reportagem de bugs e sugestões de features são bem vindas! E isso tudo é só o\n  começo;\n  "),Lo=d(Ss,"A",{href:!0});var Is=m(Lo);Qo=u(Is,"react-redux-api-tools"),Is.forEach(c),yo=u(Ss,"\n  traz um monte de outras features que não consegui descrever nesse post. Dê uma\n  boa olhada na nossa documentação para descobrir como melhorar e simplificar\n  seu código usando nossas ferramentas! Obrigado, e até a próxima!"),Ss.forEach(c),this.h()},h(){document.title="\n    Desacoplando a lógica de componentes React - luciano@ratamero.com\n  ",p(a,"name","description"),p(a,"content","Nesse post, discutiremos como separar as lógicas de renderização e de domínio usando React e Redux :]"),p(o,"name","keywords"),p(o,"content","Luciano Ratamero, react, redux, grandes projetos, arquitetura, planejamento, frontend, javascript, frameworks"),p(A,"class","meta"),T.src!==(M=g)&&p(T,"src",M),p(T,"alt","Ilustração com as logos do React e do Redux"),p(H,"href","/en/decoupling-logic-from-react-components/"),p(oe,"alt","primeiro código"),oe.src!==(se=h)&&p(oe,"src",se),p(Ke,"alt","segundo código"),Ke.src!==(We=q)&&p(Ke,"src",We),p(ea,"alt","primeiro processo"),ea.src!==(aa=E)&&p(ea,"src",aa),p(la,"alt","terceiro codigo"),la.src!==(va=b)&&p(la,"src",va),p(La,"alt","segundo processo"),La.src!==(Qa=x)&&p(La,"src",Qa),p(Za,"alt","quarto codigo"),Za.src!==($a=R)&&p(Za,"src",$a),p(So,"alt","quinto codigo"),So.src!==(Go=S)&&p(So,"src",Go),p(Po,"alt","sexto codigo"),Po.src!==(zo=G)&&p(Po,"src",zo),p(Bo,"href","https://www.npmjs.com/package/react-redux-api-tools"),p(Lo,"href","https://www.npmjs.com/package/react-redux-api-tools")},m(e,s){l(document.head,a),l(document.head,o),v(e,I,s),v(e,O,s),l(O,P),l(P,z),v(e,w,s),v(e,A,s),l(A,N),v(e,j,s),v(e,k,s),l(k,T),v(e,F,s),v(e,D,s),l(D,U),l(U,C),l(U,H),l(H,B),v(e,J,s),v(e,V,s),l(V,L),l(V,Q),l(Q,y),l(V,K),v(e,W,s),v(e,X,s),l(X,Y),v(e,Z,s),v(e,$,s),l($,_),v(e,ee,s),v(e,ae,s),l(ae,oe),v(e,re,s),v(e,ne,s),l(ne,ie),l(ne,de),l(de,ce),l(ne,te),v(e,me,s),v(e,ue,s),l(ue,pe),l(ue,le),l(le,ve),l(ue,fe),l(ue,ge),l(ge,he),l(ue,qe),l(ue,Ee),l(ue,be),l(ue,xe),l(ue,Re),l(ue,Se),l(Se,Ge),l(ue,Ie),l(ue,Oe),l(ue,Pe),l(ue,ze),l(ze,we),l(ue,Ae),l(ue,Ne),l(ue,je),l(ue,ke),l(ke,Te),l(ue,Me),v(e,Fe,s),v(e,De,s),l(De,Ue),v(e,Ce,s),v(e,He,s),l(He,Be),v(e,Je,s),v(e,Ve,s),l(Ve,Le),v(e,Qe,s),v(e,ye,s),l(ye,Ke),v(e,Xe,s),v(e,Ye,s),l(Ye,Ze),v(e,$e,s),v(e,_e,s),l(_e,ea),v(e,oa,s),v(e,sa,s),l(sa,ra),l(sa,na),l(na,ia),l(sa,da),l(sa,ca),l(ca,ta),l(sa,ma),v(e,ua,s),v(e,pa,s),l(pa,la),v(e,fa,s),v(e,ga,s),l(ga,ha),l(ga,qa),l(qa,Ea),l(ga,ba),v(e,xa,s),v(e,Ra,s),l(Ra,Sa),v(e,Ga,s),v(e,Ia,s),l(Ia,Oa),l(Ia,Pa),l(Pa,za),l(Ia,wa),l(Ia,Aa),l(Aa,Na),l(Ia,ja),l(Ia,ka),l(ka,Ta),l(Ia,Ma),l(Ia,Fa),l(Fa,Da),l(Ia,Ua),l(Ia,Ca),l(Ca,Ha),l(Ia,Ba),v(e,Ja,s),v(e,Va,s),l(Va,La),v(e,ya,s),v(e,Ka,s),l(Ka,Wa),v(e,Xa,s),v(e,Ya,s),l(Ya,Za),v(e,_a,s),v(e,eo,s),l(eo,ao),l(eo,oo),l(oo,so),l(eo,ro),l(eo,no),l(no,io),l(eo,co),l(eo,to),l(to,mo),l(eo,uo),l(eo,po),l(po,lo),l(eo,vo),l(eo,fo),l(fo,go),l(eo,ho),l(eo,qo),l(qo,Eo),l(eo,bo),v(e,xo,s),v(e,Ro,s),l(Ro,So),v(e,Io,s),v(e,Oo,s),l(Oo,Po),v(e,wo,s),v(e,Ao,s),l(Ao,No),l(Ao,jo),l(jo,ko),l(Ao,To),v(e,Mo,s),v(e,Fo,s),l(Fo,Do),v(e,Uo,s),v(e,Co,s),l(Co,Ho),l(Co,Bo),l(Bo,Jo),l(Co,Vo),l(Co,Lo),l(Lo,Qo),l(Co,yo)},p:f,i:f,o:f,d(e){c(a),c(o),e&&c(I),e&&c(O),e&&c(w),e&&c(A),e&&c(j),e&&c(k),e&&c(F),e&&c(D),e&&c(J),e&&c(V),e&&c(W),e&&c(X),e&&c(Z),e&&c($),e&&c(ee),e&&c(ae),e&&c(re),e&&c(ne),e&&c(me),e&&c(ue),e&&c(Fe),e&&c(De),e&&c(Ce),e&&c(He),e&&c(Je),e&&c(Ve),e&&c(Qe),e&&c(ye),e&&c(Xe),e&&c(Ye),e&&c($e),e&&c(_e),e&&c(oa),e&&c(sa),e&&c(ua),e&&c(pa),e&&c(fa),e&&c(ga),e&&c(xa),e&&c(Ra),e&&c(Ga),e&&c(Ia),e&&c(Ja),e&&c(Va),e&&c(ya),e&&c(Ka),e&&c(Xa),e&&c(Ya),e&&c(_a),e&&c(eo),e&&c(xo),e&&c(Ro),e&&c(Io),e&&c(Oo),e&&c(wo),e&&c(Ao),e&&c(Mo),e&&c(Fo),e&&c(Uo),e&&c(Co)}}}export default class extends e{constructor(e){super(),a(this,e,null,I,o,{})}}
