import{S as e,i as t,s as o,E as a,w as n,F as s,G as r,c as i,e as c,x as l,d as h,H as d,k as u,I as m,g as f,n as p}from"./client.ba4c128a.js";import{c as g,i as w,a as v,b,d as y,e as E,f as k,g as I,h as T}from"./image8.948aeaf3.js";function R(e){let t,o,R,x,G,S,A,j,P,O,q,F,M,N,U,D,C,L,B,H,W,z,Y,K,J,Q,V,X,Z,$,_,ee,te,oe,ae,ne,se,re,ie,ce,le,he,de,ue,me,fe,pe,ge,we,ve,be,ye,Ee,ke,Ie,Te,Re,xe,Ge,Se,Ae,je,Pe,Oe,qe,Fe,Me,Ne,Ue,De,Ce,Le,Be,He,We,ze,Ye,Ke,Je,Qe,Ve,Xe,Ze,$e,_e,et,tt,ot,at,nt,st,rt,it,ct,lt,ht,dt,ut,mt,ft,pt,gt,wt,vt,bt,yt,Et,kt,It,Tt,Rt,xt,Gt,St,At,jt,Pt,Ot,qt,Ft,Mt,Nt,Ut,Dt,Ct,Lt,Bt,Ht,Wt,zt,Yt,Kt,Jt,Qt,Vt,Xt,Zt,$t,_t,eo,to,oo,ao,no,so,ro,io,co,lo,ho,uo,mo,fo,po,go,wo,vo,bo,yo,Eo,ko,Io,To,Ro,xo,Go,So,Ao,jo,Po,Oo,qo,Fo;return{c(){t=a("meta"),o=a("meta"),R=n(),x=a("h1"),G=a("mark"),S=s("Decoupling logic from react components"),A=n(),j=a("p"),P=s("2019-07-23"),O=n(),q=a("figure"),F=a("img"),N=n(),U=a("p"),D=s("Whenever there’s a new React project, most frontend developers will fumble\n  around with the basic configurations. Patterns of style implementation,\n  component decoupling and folder structure will emerge -\n  "),C=a("strong"),L=s("not always for the good"),B=s(". The worst part is that every single\n  frontend dev I’ve ever seen will solve the biggest problem of them all, the\n  "),H=a("em"),W=s("business logic"),z=s("\n  conundrum, in a different way. In an effort to create a standard to solve the\n  domain layer issue at Labcodes, I’ve researched a bit and found a good and\n  sustainable way to deal with requests and data processing. The end result:\n  react-redux-api-tools."),Y=n(),K=a("h2"),J=s("Let’s imagine a common scenario: CRUD"),Q=n(),V=a("p"),X=s("Since javascript is too permissive, there are endless ways to make a CRUD SPA.\n  Limiting the scope to react helps a bit, but there are still way too many\n  different possible implementations. One of them is to use lifecycle hooks to\n  make requests. Your code may look a bit like this:"),Z=n(),$=a("figure"),_=a("img"),te=n(),oe=a("p"),ae=s("I think I don’t need to say this, but I’ll do it anyway: this implementation,\n  even though it’s completely valid, has some\n  "),ne=a("strong"),se=s("big"),re=s("\n  drawbacks."),ie=n(),ce=a("p"),le=s("1.The request is being made inside a component, which, in theory, should have\n  only one job:\n  "),he=a("strong"),de=s("render data"),ue=s(". If, for example, you needed to clear out a\n  user’s session or any other business logic, it would probably be here, and\n  that’s\n  "),me=a("strong"),fe=s("even worse"),pe=s(";"),ge=a("br"),we=s("\n  2. The response data lives\n  "),ve=a("strong"),be=s("inside"),ye=s("\n  the component’s state, and that means that it’s gone as soon as the component\n  unmounts;"),Ee=a("br"),ke=s("\n  3. You’ll have to\n  "),Ie=a("strong"),Te=s("always"),Re=s("\n  fetch the data for each instance of the component, even if that specific\n  request was already done a billion times;"),xe=a("br"),Ge=s("\n  4. There is no specific middle state between the request start and the\n  response, so no loading spinners (though you may be able to implement it using\n  setState callback hells);"),Se=a("br"),Ae=s("\n  5. Since react components are hierarchical, if you need this data inside a\n  child or a parent component, you’ll need to implement contexts/props and\n  callbacks.\n  "),je=a("strong"),Pe=s("It gets messy. FAST."),Oe=a("br"),qe=n(),Fe=a("p"),Me=s("To make it better, most of us prefer to use a library to provide a global\n  application state; one that lives outside all components."),Ne=n(),Ue=a("h2"),De=s("Second step: use Redux"),Ce=n(),Le=a("p"),Be=s("Redux is one of the most amazing tools for the job. So let’s say you’re using\n  redux to manage the data and business logic. Assuming you’ll be using the\n  reducers to deal with business logic and data formatting, your component code\n  will probably look a bit like this:"),He=n(),We=a("figure"),ze=a("img"),Ke=n(),Je=a("p"),Qe=s("This solves most of the issues, but I would argue that this solution makes\n  everything\n  "),Ve=a("strong"),Xe=s("even more coupled"),Ze=s("\n  and, for sure,\n  "),$e=a("strong"),_e=s("worse to read and maintain"),et=s(". The root cause of the issue is\n  that the component is still being responsible for\n  "),tt=a("strong"),ot=s("everything"),at=s(": fetching the data and orchestrating redux\n  actions, when it’s only supposed to... render stuff. The ideal flow to solve\n  all issues,\n  "),nt=a("em"),st=s("at least the best for most cases"),rt=s(", would be something akin to the\n  following flowchart:"),it=n(),ct=a("figure"),lt=a("img"),dt=n(),ut=a("p"),mt=s("Note that the only way to remove completely the business logic from the\n  component is to trigger the ‘Success’ and ‘Failure’ use cases\n  "),ft=a("strong"),pt=s("outside"),gt=s("\n  of the component. Components should render stuff, not deal with\n  "),wt=a("strong"),vt=s("application-wide"),bt=s("\n  state management. That means that the component should only dispatch one event\n  (the\n  "),yt=a("em"),Et=s("‘get me the data’"),kt=s("\n  event), then react to it whenever the data is there. For that, our component\n  code would need to be as simple as this:"),It=n(),Tt=a("figure"),Rt=a("img"),Gt=n(),St=a("p"),At=s("And that means that… the actions should fetch the data? And reducers would\n  dispatch actions? Sounds weird, right? Because it is. And it’s not what I’m\n  suggesting whatsoever."),jt=n(),Pt=a("h2"),Ot=s("Enter the middlewares"),qt=n(),Ft=a("p"),Mt=s("To deliver the ideal data flow,\n  "),Nt=a("strong"),Ut=s("redux middlewares are amazing"),Dt=s(". Let’s say we want our\n  component to be exactly like that last bit of code. If we had something in\n  between actions and reducers, for example, we could make this\n  "),Ct=a("strong"),Lt=s("inbetween"),Bt=s("\n  code deal with fetching the data and figuring out which reducers to fire,\n  leaving redux to do its job of managing state and events, while leaving\n  components focused on their jobs of rendering, and rendering only. The data\n  flow would be something like this:"),Ht=n(),Wt=a("figure"),zt=a("img"),Kt=n(),Jt=a("p"),Qt=s("With this proposed flow, our action could look like this:"),Vt=n(),Xt=a("figure"),Zt=a("img"),_t=n(),eo=a("p"),to=s("Ok, let’s slow down. What you see above is the current API for a request\n  action, using the middleware included in our\n  "),oo=a("code"),ao=s("[react-redux-api-tools](https://www.npmjs.com/package/react-redux-api-tools)"),no=s("\n  npm package. Dispatching this action would configure the middleware to make\n  the request (by calling\n  "),so=a("code"),ro=s("apiCallFunction"),io=s(") and to use the correct reducer whenever the\n  request is done. Meanwhile, our component and reducers would remain unaltered:"),co=n(),lo=a("figure"),ho=a("img"),mo=n(),fo=a("figure"),po=a("img"),wo=n(),vo=a("p"),bo=s("And "),yo=a("em"),Eo=s("voilá"),ko=s(", the flow is much cleaner, simpler and decoupled!"),Io=n(),To=a("h2"),Ro=s("If you liked this or it seems too magical..."),xo=n(),Go=a("p"),So=s("Have you enjoyed this middleware API, want to develop your react-redux app\n  like this or are just curious on how this all works? Then consider using and\n  contributing to our\n  "),Ao=a("a"),jo=s("react-redux-api-tools"),Po=s("\n  npm package. Bugs and feature proposals are welcome! And this is only the\n  start;\n  "),Oo=a("a"),qo=s("react-redux-api-tools"),Fo=s("\n  has a bunch of other features I’ve not talked about. Give our docs a good read\n  to find out how to further improve and simplify your code using our tools!\n  Thanks, and see you later!"),this.h()},l(e){const a=r('[data-svelte="svelte-1shf3cp"]',document.head);t=i(a,"META",{name:!0,content:!0}),o=i(a,"META",{name:!0,content:!0}),a.forEach(c),R=l(e),x=i(e,"H1",{});var n=h(x);G=i(n,"MARK",{});var s=h(G);S=d(s,"Decoupling logic from react components"),s.forEach(c),n.forEach(c),A=l(e),j=i(e,"P",{class:!0});var u=h(j);P=d(u,"2019-07-23"),u.forEach(c),O=l(e),q=i(e,"FIGURE",{});var m=h(q);F=i(m,"IMG",{src:!0,alt:!0}),m.forEach(c),N=l(e),U=i(e,"P",{});var f=h(U);D=d(f,"Whenever there’s a new React project, most frontend developers will fumble\n  around with the basic configurations. Patterns of style implementation,\n  component decoupling and folder structure will emerge -\n  "),C=i(f,"STRONG",{});var p=h(C);L=d(p,"not always for the good"),p.forEach(c),B=d(f,". The worst part is that every single\n  frontend dev I’ve ever seen will solve the biggest problem of them all, the\n  "),H=i(f,"EM",{});var g=h(H);W=d(g,"business logic"),g.forEach(c),z=d(f,"\n  conundrum, in a different way. In an effort to create a standard to solve the\n  domain layer issue at Labcodes, I’ve researched a bit and found a good and\n  sustainable way to deal with requests and data processing. The end result:\n  react-redux-api-tools."),f.forEach(c),Y=l(e),K=i(e,"H2",{});var w=h(K);J=d(w,"Let’s imagine a common scenario: CRUD"),w.forEach(c),Q=l(e),V=i(e,"P",{});var v=h(V);X=d(v,"Since javascript is too permissive, there are endless ways to make a CRUD SPA.\n  Limiting the scope to react helps a bit, but there are still way too many\n  different possible implementations. One of them is to use lifecycle hooks to\n  make requests. Your code may look a bit like this:"),v.forEach(c),Z=l(e),$=i(e,"FIGURE",{});var b=h($);_=i(b,"IMG",{alt:!0,src:!0}),b.forEach(c),te=l(e),oe=i(e,"P",{});var y=h(oe);ae=d(y,"I think I don’t need to say this, but I’ll do it anyway: this implementation,\n  even though it’s completely valid, has some\n  "),ne=i(y,"STRONG",{});var E=h(ne);se=d(E,"big"),E.forEach(c),re=d(y,"\n  drawbacks."),y.forEach(c),ie=l(e),ce=i(e,"P",{});var k=h(ce);le=d(k,"1.The request is being made inside a component, which, in theory, should have\n  only one job:\n  "),he=i(k,"STRONG",{});var I=h(he);de=d(I,"render data"),I.forEach(c),ue=d(k,". If, for example, you needed to clear out a\n  user’s session or any other business logic, it would probably be here, and\n  that’s\n  "),me=i(k,"STRONG",{});var T=h(me);fe=d(T,"even worse"),T.forEach(c),pe=d(k,";"),ge=i(k,"BR",{}),we=d(k,"\n  2. The response data lives\n  "),ve=i(k,"STRONG",{});var M=h(ve);be=d(M,"inside"),M.forEach(c),ye=d(k,"\n  the component’s state, and that means that it’s gone as soon as the component\n  unmounts;"),Ee=i(k,"BR",{}),ke=d(k,"\n  3. You’ll have to\n  "),Ie=i(k,"STRONG",{});var ee=h(Ie);Te=d(ee,"always"),ee.forEach(c),Re=d(k,"\n  fetch the data for each instance of the component, even if that specific\n  request was already done a billion times;"),xe=i(k,"BR",{}),Ge=d(k,"\n  4. There is no specific middle state between the request start and the\n  response, so no loading spinners (though you may be able to implement it using\n  setState callback hells);"),Se=i(k,"BR",{}),Ae=d(k,"\n  5. Since react components are hierarchical, if you need this data inside a\n  child or a parent component, you’ll need to implement contexts/props and\n  callbacks.\n  "),je=i(k,"STRONG",{});var Ye=h(je);Pe=d(Ye,"It gets messy. FAST."),Ye.forEach(c),Oe=i(k,"BR",{}),k.forEach(c),qe=l(e),Fe=i(e,"P",{});var ht=h(Fe);Me=d(ht,"To make it better, most of us prefer to use a library to provide a global\n  application state; one that lives outside all components."),ht.forEach(c),Ne=l(e),Ue=i(e,"H2",{});var xt=h(Ue);De=d(xt,"Second step: use Redux"),xt.forEach(c),Ce=l(e),Le=i(e,"P",{});var Yt=h(Le);Be=d(Yt,"Redux is one of the most amazing tools for the job. So let’s say you’re using\n  redux to manage the data and business logic. Assuming you’ll be using the\n  reducers to deal with business logic and data formatting, your component code\n  will probably look a bit like this:"),Yt.forEach(c),He=l(e),We=i(e,"FIGURE",{});var $t=h(We);ze=i($t,"IMG",{alt:!0,src:!0}),$t.forEach(c),Ke=l(e),Je=i(e,"P",{});var uo=h(Je);Qe=d(uo,"This solves most of the issues, but I would argue that this solution makes\n  everything\n  "),Ve=i(uo,"STRONG",{});var go=h(Ve);Xe=d(go,"even more coupled"),go.forEach(c),Ze=d(uo,"\n  and, for sure,\n  "),$e=i(uo,"STRONG",{});var Mo=h($e);_e=d(Mo,"worse to read and maintain"),Mo.forEach(c),et=d(uo,". The root cause of the issue is\n  that the component is still being responsible for\n  "),tt=i(uo,"STRONG",{});var No=h(tt);ot=d(No,"everything"),No.forEach(c),at=d(uo,": fetching the data and orchestrating redux\n  actions, when it’s only supposed to... render stuff. The ideal flow to solve\n  all issues,\n  "),nt=i(uo,"EM",{});var Uo=h(nt);st=d(Uo,"at least the best for most cases"),Uo.forEach(c),rt=d(uo,", would be something akin to the\n  following flowchart:"),uo.forEach(c),it=l(e),ct=i(e,"FIGURE",{});var Do=h(ct);lt=i(Do,"IMG",{alt:!0,src:!0}),Do.forEach(c),dt=l(e),ut=i(e,"P",{});var Co=h(ut);mt=d(Co,"Note that the only way to remove completely the business logic from the\n  component is to trigger the ‘Success’ and ‘Failure’ use cases\n  "),ft=i(Co,"STRONG",{});var Lo=h(ft);pt=d(Lo,"outside"),Lo.forEach(c),gt=d(Co,"\n  of the component. Components should render stuff, not deal with\n  "),wt=i(Co,"STRONG",{});var Bo=h(wt);vt=d(Bo,"application-wide"),Bo.forEach(c),bt=d(Co,"\n  state management. That means that the component should only dispatch one event\n  (the\n  "),yt=i(Co,"EM",{});var Ho=h(yt);Et=d(Ho,"‘get me the data’"),Ho.forEach(c),kt=d(Co,"\n  event), then react to it whenever the data is there. For that, our component\n  code would need to be as simple as this:"),Co.forEach(c),It=l(e),Tt=i(e,"FIGURE",{});var Wo=h(Tt);Rt=i(Wo,"IMG",{alt:!0,src:!0}),Wo.forEach(c),Gt=l(e),St=i(e,"P",{});var zo=h(St);At=d(zo,"And that means that… the actions should fetch the data? And reducers would\n  dispatch actions? Sounds weird, right? Because it is. And it’s not what I’m\n  suggesting whatsoever."),zo.forEach(c),jt=l(e),Pt=i(e,"H2",{});var Yo=h(Pt);Ot=d(Yo,"Enter the middlewares"),Yo.forEach(c),qt=l(e),Ft=i(e,"P",{});var Ko=h(Ft);Mt=d(Ko,"To deliver the ideal data flow,\n  "),Nt=i(Ko,"STRONG",{});var Jo=h(Nt);Ut=d(Jo,"redux middlewares are amazing"),Jo.forEach(c),Dt=d(Ko,". Let’s say we want our\n  component to be exactly like that last bit of code. If we had something in\n  between actions and reducers, for example, we could make this\n  "),Ct=i(Ko,"STRONG",{});var Qo=h(Ct);Lt=d(Qo,"inbetween"),Qo.forEach(c),Bt=d(Ko,"\n  code deal with fetching the data and figuring out which reducers to fire,\n  leaving redux to do its job of managing state and events, while leaving\n  components focused on their jobs of rendering, and rendering only. The data\n  flow would be something like this:"),Ko.forEach(c),Ht=l(e),Wt=i(e,"FIGURE",{});var Vo=h(Wt);zt=i(Vo,"IMG",{alt:!0,src:!0}),Vo.forEach(c),Kt=l(e),Jt=i(e,"P",{});var Xo=h(Jt);Qt=d(Xo,"With this proposed flow, our action could look like this:"),Xo.forEach(c),Vt=l(e),Xt=i(e,"FIGURE",{});var Zo=h(Xt);Zt=i(Zo,"IMG",{alt:!0,src:!0}),Zo.forEach(c),_t=l(e),eo=i(e,"P",{});var $o=h(eo);to=d($o,"Ok, let’s slow down. What you see above is the current API for a request\n  action, using the middleware included in our\n  "),oo=i($o,"CODE",{});var _o=h(oo);ao=d(_o,"[react-redux-api-tools](https://www.npmjs.com/package/react-redux-api-tools)"),_o.forEach(c),no=d($o,"\n  npm package. Dispatching this action would configure the middleware to make\n  the request (by calling\n  "),so=i($o,"CODE",{});var ea=h(so);ro=d(ea,"apiCallFunction"),ea.forEach(c),io=d($o,") and to use the correct reducer whenever the\n  request is done. Meanwhile, our component and reducers would remain unaltered:"),$o.forEach(c),co=l(e),lo=i(e,"FIGURE",{});var ta=h(lo);ho=i(ta,"IMG",{alt:!0,src:!0}),ta.forEach(c),mo=l(e),fo=i(e,"FIGURE",{});var oa=h(fo);po=i(oa,"IMG",{alt:!0,src:!0}),oa.forEach(c),wo=l(e),vo=i(e,"P",{});var aa=h(vo);bo=d(aa,"And "),yo=i(aa,"EM",{});var na=h(yo);Eo=d(na,"voilá"),na.forEach(c),ko=d(aa,", the flow is much cleaner, simpler and decoupled!"),aa.forEach(c),Io=l(e),To=i(e,"H2",{});var sa=h(To);Ro=d(sa,"If you liked this or it seems too magical..."),sa.forEach(c),xo=l(e),Go=i(e,"P",{});var ra=h(Go);So=d(ra,"Have you enjoyed this middleware API, want to develop your react-redux app\n  like this or are just curious on how this all works? Then consider using and\n  contributing to our\n  "),Ao=i(ra,"A",{href:!0});var ia=h(Ao);jo=d(ia,"react-redux-api-tools"),ia.forEach(c),Po=d(ra,"\n  npm package. Bugs and feature proposals are welcome! And this is only the\n  start;\n  "),Oo=i(ra,"A",{href:!0});var ca=h(Oo);qo=d(ca,"react-redux-api-tools"),ca.forEach(c),Fo=d(ra,"\n  has a bunch of other features I’ve not talked about. Give our docs a good read\n  to find out how to further improve and simplify your code using our tools!\n  Thanks, and see you later!"),ra.forEach(c),this.h()},h(){document.title="Decoupling logic from react components - luciano@ratamero.com",u(t,"name","description"),u(t,"content","In this post, we'll discuss how to decouple rendering from domain login using React and Redux :]"),u(o,"name","keywords"),u(o,"content","Luciano Ratamero, react, redux, big projects, architecture, planning, frontend, javascript, frameworks"),u(j,"class","meta"),F.src!==(M=g)&&u(F,"src",M),u(F,"alt","Logos of React and Redux"),u(_,"alt","first code"),_.src!==(ee=w)&&u(_,"src",ee),u(ze,"alt","segundo código"),ze.src!==(Ye=v)&&u(ze,"src",Ye),u(lt,"alt","primeiro processo"),lt.src!==(ht=b)&&u(lt,"src",ht),u(Rt,"alt","terceiro codigo"),Rt.src!==(xt=y)&&u(Rt,"src",xt),u(zt,"alt","segundo processo"),zt.src!==(Yt=E)&&u(zt,"src",Yt),u(Zt,"alt","quarto codigo"),Zt.src!==($t=k)&&u(Zt,"src",$t),u(ho,"alt","quinto codigo"),ho.src!==(uo=I)&&u(ho,"src",uo),u(po,"alt","sexto codigo"),po.src!==(go=T)&&u(po,"src",go),u(Ao,"href","https://www.npmjs.com/package/react-redux-api-tools"),u(Oo,"href","https://www.npmjs.com/package/react-redux-api-tools")},m(e,a){m(document.head,t),m(document.head,o),f(e,R,a),f(e,x,a),m(x,G),m(G,S),f(e,A,a),f(e,j,a),m(j,P),f(e,O,a),f(e,q,a),m(q,F),f(e,N,a),f(e,U,a),m(U,D),m(U,C),m(C,L),m(U,B),m(U,H),m(H,W),m(U,z),f(e,Y,a),f(e,K,a),m(K,J),f(e,Q,a),f(e,V,a),m(V,X),f(e,Z,a),f(e,$,a),m($,_),f(e,te,a),f(e,oe,a),m(oe,ae),m(oe,ne),m(ne,se),m(oe,re),f(e,ie,a),f(e,ce,a),m(ce,le),m(ce,he),m(he,de),m(ce,ue),m(ce,me),m(me,fe),m(ce,pe),m(ce,ge),m(ce,we),m(ce,ve),m(ve,be),m(ce,ye),m(ce,Ee),m(ce,ke),m(ce,Ie),m(Ie,Te),m(ce,Re),m(ce,xe),m(ce,Ge),m(ce,Se),m(ce,Ae),m(ce,je),m(je,Pe),m(ce,Oe),f(e,qe,a),f(e,Fe,a),m(Fe,Me),f(e,Ne,a),f(e,Ue,a),m(Ue,De),f(e,Ce,a),f(e,Le,a),m(Le,Be),f(e,He,a),f(e,We,a),m(We,ze),f(e,Ke,a),f(e,Je,a),m(Je,Qe),m(Je,Ve),m(Ve,Xe),m(Je,Ze),m(Je,$e),m($e,_e),m(Je,et),m(Je,tt),m(tt,ot),m(Je,at),m(Je,nt),m(nt,st),m(Je,rt),f(e,it,a),f(e,ct,a),m(ct,lt),f(e,dt,a),f(e,ut,a),m(ut,mt),m(ut,ft),m(ft,pt),m(ut,gt),m(ut,wt),m(wt,vt),m(ut,bt),m(ut,yt),m(yt,Et),m(ut,kt),f(e,It,a),f(e,Tt,a),m(Tt,Rt),f(e,Gt,a),f(e,St,a),m(St,At),f(e,jt,a),f(e,Pt,a),m(Pt,Ot),f(e,qt,a),f(e,Ft,a),m(Ft,Mt),m(Ft,Nt),m(Nt,Ut),m(Ft,Dt),m(Ft,Ct),m(Ct,Lt),m(Ft,Bt),f(e,Ht,a),f(e,Wt,a),m(Wt,zt),f(e,Kt,a),f(e,Jt,a),m(Jt,Qt),f(e,Vt,a),f(e,Xt,a),m(Xt,Zt),f(e,_t,a),f(e,eo,a),m(eo,to),m(eo,oo),m(oo,ao),m(eo,no),m(eo,so),m(so,ro),m(eo,io),f(e,co,a),f(e,lo,a),m(lo,ho),f(e,mo,a),f(e,fo,a),m(fo,po),f(e,wo,a),f(e,vo,a),m(vo,bo),m(vo,yo),m(yo,Eo),m(vo,ko),f(e,Io,a),f(e,To,a),m(To,Ro),f(e,xo,a),f(e,Go,a),m(Go,So),m(Go,Ao),m(Ao,jo),m(Go,Po),m(Go,Oo),m(Oo,qo),m(Go,Fo)},p:p,i:p,o:p,d(e){c(t),c(o),e&&c(R),e&&c(x),e&&c(A),e&&c(j),e&&c(O),e&&c(q),e&&c(N),e&&c(U),e&&c(Y),e&&c(K),e&&c(Q),e&&c(V),e&&c(Z),e&&c($),e&&c(te),e&&c(oe),e&&c(ie),e&&c(ce),e&&c(qe),e&&c(Fe),e&&c(Ne),e&&c(Ue),e&&c(Ce),e&&c(Le),e&&c(He),e&&c(We),e&&c(Ke),e&&c(Je),e&&c(it),e&&c(ct),e&&c(dt),e&&c(ut),e&&c(It),e&&c(Tt),e&&c(Gt),e&&c(St),e&&c(jt),e&&c(Pt),e&&c(qt),e&&c(Ft),e&&c(Ht),e&&c(Wt),e&&c(Kt),e&&c(Jt),e&&c(Vt),e&&c(Xt),e&&c(_t),e&&c(eo),e&&c(co),e&&c(lo),e&&c(mo),e&&c(fo),e&&c(wo),e&&c(vo),e&&c(Io),e&&c(To),e&&c(xo),e&&c(Go)}}}export default class extends e{constructor(e){super(),t(this,e,null,R,o,{})}}
