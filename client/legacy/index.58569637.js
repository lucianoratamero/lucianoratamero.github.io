import{_ as e,a,b as o,c as s,i as r,d as n,S as i,s as t,T as d,g as c,f as u,e as m,t as p,q as l,n as f,j as g,k as v,h,l as q,m as E,o as x,u as R,r as b,p as $,C as P,w as S,x as C,y as z,M as I}from"./client.eda691f8.js";import"./Icon.0e3deb14.js";import{M as O,P as L}from"./MetaTags.6b7c1de8.js";import{H as w,j as T}from"./index.9c2fd222.js";import{c as D}from"./cover.e41aed43.js";function A(e){var s=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(e){return!1}}();return function(){var r,n=a(e);if(s){var i=a(this).constructor;r=Reflect.construct(n,arguments,i)}else r=n.apply(this,arguments);return o(this,r)}}function j(e){var a,o,s,r,n,i,t,I,A,j,N,G,U,k,M,F,H,_,y,B,J,Q,V,K,W,X,Y,Z,ee,ae,oe,se,re,ne,ie,te,de,ce,ue,me,pe,le,fe,ge,ve,he,qe,Ee,xe,Re,be,$e,Pe,Se,Ce,ze,Ie,Oe,Le,we,Te,De,Ae,je,Ne,Ge,Ue,ke,Me,Fe,He,_e,ye,Be,Je,Qe,Ve,Ke,We,Xe,Ye,Ze,ea,aa,oa,sa,ra,na,ia,ta,da,ca,ua,ma,pa,la,fa,ga,va,ha,qa,Ea,xa,Ra,ba,$a,Pa,Sa,Ca,za,Ia,Oa,La,wa,Ta,Da,Aa,ja,Na,Ga,Ua,ka,Ma,Fa,Ha,_a,ya,Ba,Ja,Qa,Va,Ka,Wa,Xa,Ya,Za,eo,ao,oo,so,ro,no,io,to,co,uo,mo,po,lo,fo,go,vo,ho,qo,Eo,xo,Ro,bo,$o,Po,So,Co,zo,Io,Oo,Lo,wo,To,Do,Ao,jo,No,Go,Uo,ko,Mo,Fo,Ho,_o,yo,Bo,Jo,Qo,Vo,Ko,Wo,Xo,Yo,Zo,es,as,os,ss,rs,ns,is,ts,ds,cs,us,ms,ps,ls,fs,gs,vs;return a=new O({props:{title:"Desacoplando a lógica de componentes React",description:"Nesse post, discutiremos como separar as lógicas de renderização e de domínio usando React e Redux :]",keywords:"react, redux, grandes projetos, arquitetura, planejamento, frontend, javascript, frameworks"}}),t=new L({props:{date:"2019-07-23",text:e[1]}}),se=new w({props:{language:T,code:d('\nexport default class Product extends React.Component {\n  // ...\n  componentDidMount() {\n    fetch("/api/products/1/")\n      .then(response => response.json())\n      .then(data => this.setState({...data}));\n  }\n  //...\n}\n')}}),Je=new w({props:{language:T,code:d('\nexport default class Product extends React.Component {\n  // ...\n  componentDidMount() {\n    const { fetchProductIsLoading, setProductData } = this.props;\n    // liga o spinner de loading via redux\n    fetchProductIsLoading();\n\n    // faz a requisição e coloca os dados na store do redux\n    fetch("/api/products/1/")\n      .then(response => response.json())\n      .then(data => setProductData(data));\n  }\n  //...\n  render() {\n    const { productIsLoading, productData } = this.props;\n    // ...\n  }\n}\n')}}),ba=new w({props:{language:T,code:d("\nexport default class Product extends React.Component {\n  // ...\n  componentDidMount() {\n    const { fetchProduct } = this.props;\n    fetchProduct();\n  }\n  //...\n  render() {\n    const { productIsLoading, productData } = this.props;\n    // ...\n  }\n}\n")}}),So=new w({props:{language:T,code:d("\nexport function fetchProduct(id) {\n  return {\n    types: {\n      request: FETCH_PRODUCT_REQUEST,\n      success: FETCH_PRODUCT_SUCCESS,\n      failure: FETCH_PRODUCT_FAILURE,\n    },\n    apiCallFunction: () => fetch(`/api/products/${id}`),\n  }\n}\n")}}),Ko=new w({props:{language:T,code:d("\nexport default class Product extends React.Component {\n  // ...\n  componentDidMount() {\n    const { fetchProduct } = this.props;\n    fetchProduct();\n  }\n  //...\n  render() {\n    const { productIsLoading, productData } = this.props;\n    // ...\n  }\n}\n")}}),Xo=new w({props:{language:T,code:d("\nexport const productReducer = (state = initialState, action) => {\n  switch(action.type) {\n    case FETCH_PRODUCT_REQUEST:\n      return {\n        ...state,\n        error: null,\n        productIsLoading: true,\n      }\n    case FETCH_PRODUCT_SUCCESS:\n      // aqui, você pode executar qualquer lógica de negócio\n      businessLogic();\n\n      return {\n        ...state,\n        error: null,\n        productIsLoading: initialState.productIsLoading,\n        productData: action.response.data,\n      }\n    case FETCH_PRODUCT_FAILURE:\n      return {\n        ...state,\n        productIsLoading: initialState.productIsLoading,\n        error: action.response.data,\n      }\n    default:\n      return state;\n  }\n}\n")}}),{c:function(){c(a.$$.fragment),o=u(),s=m("h1"),r=m("mark"),n=p("Desacoplando a lógica de componentes React"),i=u(),c(t.$$.fragment),I=u(),A=m("figure"),j=m("img"),G=u(),U=m("p"),k=m("em"),M=p("for native english speakers,\n    "),F=m("a"),H=p("here's the translated\n      post"),_=u(),y=m("article"),B=m("p"),J=p("Sempre que há um novo projeto baseado em React, grande parte dos devs\n    frontend irão passar pelo ritual de configuração inicial. Padrões de\n    implementação de estilos, desacoplamento de componentes e estrutura de\n    diretórios irão emergir -\n    "),Q=m("strong"),V=p("nem sempre pro bem"),K=p(". O pior é que todo dev frontend que eu\n    já vi irá resolver o maior problema de todos, o problema de desacoplar\n    lógica de negócio, de uma forma diferente. Em um esforço para criar uma\n    padronização e resolver a questão da camada de domínio aqui na Labcodes, eu\n    pesquisei um bocado e achei uma forma boa e sustentável para lidar com\n    requisições e processamento de dados. O resultado: react-redux-api-tools."),W=u(),X=m("h2"),Y=p("Vamos imaginar um cenário comum: CRUD"),Z=u(),ee=m("p"),ae=p("Já que o javascript é muito permissivo, há inúmeras maneiras de\n    implementarmos um CRUD em uma SPA. Se limitarmos o escopo ao uso do react,\n    as coisas ficam mais fáceis, mas ainda há possíveis implementações demais.\n    Uma delas é de usar os hooks de ciclo de vida para fazer as requisições. Seu\n    código provavelmente irá ficar parecido com isso:"),oe=u(),c(se.$$.fragment),re=u(),ne=m("p"),ie=p("Eu acho que não preciso falar muito sobre isso, mas vou falar de qualquer\n    forma: essa implementação, mesmo sendo perfeitamente válida, tem alguns\n    "),te=m("strong"),de=p("grandes"),ce=p("\n    problemas."),ue=u(),me=m("p"),pe=p("1.A requisição está sendo feita dentro do componente que, em teoria, deveria\n    ter apenas um trabalho:\n    "),le=m("strong"),fe=p("renderizar os dados"),ge=p(". Se, por exemplo, você precisasse\n    limpar a sessão do usuário ou executar qualquer lógica de negócio, ela\n    provavelmente estaria aqui, o que é\n    "),ve=m("strong"),he=p("ainda pior"),qe=p(";"),Ee=m("br"),xe=p("\n    2. Os dados da resposta da requisição está vivendo dentro do estado do\n    componente, e isso significa que tudo será perdido assim que o componente\n    desmontar;"),Re=m("br"),be=p("\n    3. Você terá\n    "),$e=m("strong"),Pe=p("sempre"),Se=p("\n    que pegar os dados da API para cada instância do componente, mesmo que já\n    tenha feito essa específica requisição um bilhão de vezes;"),Ce=m("br"),ze=p("\n    4. Não há nenhum estado intermediário entre o início da requisição e sua\n    resposta, então nada de spinners de loading (apesar de você poder\n    implementar essa lógica construindo um\n    "),Ie=m("em"),Oe=p("callback hell"),Le=p("\n    de setStates);"),we=m("br"),Te=p("\n    5. Já que componentes react são hierárquicos, se você precisar desses dados\n    dentro de um componente filho ou pai, você terá que implementar\n    contextos/props e callbacks.\n    "),De=m("strong"),Ae=p("O código fica complicado. RAPIDINHO."),je=m("br"),Ne=u(),Ge=m("p"),Ue=p("Para melhorar esse código, muitos de nós preferem usar uma biblioteca para\n    prover um estado mais global para a aplicação; um estado que vive fora de\n    todos os componentes."),ke=u(),Me=m("h2"),Fe=p("Segundo passo: usando Redux"),He=u(),_e=m("p"),ye=p("Redux é uma das melhores bibliotecas para esse tipo de trabalho. Digamos que\n    você vai usar redux para lidar com dados e lógica de negócio. Assumindo que\n    você usará a camada de reducers para formatar dados e chamar lógicas de\n    domínio, seu componente vai ficar mais ou menos assim:"),Be=u(),c(Je.$$.fragment),Qe=u(),Ve=m("p"),Ke=p("Isso resolve grande parte dos problemas, mas eu diria que essa solução\n    acopla ainda mais o código e, certeza, deixa ele mais difícil de ler e\n    manter. A causa raiz disso tudo é o fato de que o componente está sendo\n    responsável por absolutamente tudo: pegar os dados da API e orquestrar\n    eventos do redux, quando era para ele estar… renderizando coisas. O fluxo\n    ideal para resolver todos os problemas, pelo menos os mais importantes,\n    seria algo similar a isso:"),We=u(),Xe=m("ul"),Ye=m("li"),Ze=p("Componente monta e levanta sinal de isLoading pro Redux"),ea=u(),aa=m("li"),oa=p("Action do Redux começa a requisição e dispara reducer de isLoading"),sa=u(),ra=m("li"),na=p("Componente renderiza isLoading"),ia=u(),ta=m("li"),da=p("Requisição termina assincronamente e dispara reducer de sucesso ou falha"),ca=u(),ua=m("li"),ma=p("Componente renderiza sucesso ou falha"),pa=u(),la=m("p"),fa=p("Note que a única forma de completamente remover a lógica de negócio dos\n    componentes é acionando os casos de uso de ‘Sucesso’ e ‘Falha’\n    "),ga=m("strong"),va=p("fora do componente"),ha=p(". Componentes devem renderizar coisas,\n    não lidar com gerenciamento de estado da\n    "),qa=m("strong"),Ea=p("aplicação inteira"),xa=p(". Isso significa que o componente apenas\n    deve avisar a alguém que precisa de dados, disparando um evento (o evento de\n    ‘pega esses dados pra mim’), e então reagir aos dados quando eles estiverem\n    lá. Para respeitar essa ideia, nosso código do componente deveria ser tão\n    simples quanto isso:"),Ra=u(),c(ba.$$.fragment),$a=u(),Pa=m("p"),Sa=p("E isso significa que… as actions devem fazer a requisição dos dados? E\n    reducers iriam disparar outras ações? Soa estranho, né? Porque é. E não é o\n    que eu estou sugerindo\n    "),Ca=m("strong"),za=p("mesmo"),Ia=p("."),Oa=u(),La=m("h2"),wa=p("Eis que chegam os middlewares"),Ta=u(),Da=m("p"),Aa=p("Para entregarmos o fluxo ideal de dados,\n    "),ja=m("strong"),Na=p("middlewares do redux são maravilhosos"),Ga=p(". Imaginem que\n    queremos que nosso componente seja exatamente como o código que vimos acima.\n    Se nós, por exemplo, tivéssemos algo entre as actions e os reducers, a gente\n    conseguiria fazer com que esse\n    "),Ua=m("em"),ka=p("código do meio"),Ma=u(),Fa=m("strong"),Ha=p("fizesse a requisição"),_a=p("\n    e, dependendo do resultado,\n    "),ya=m("strong"),Ba=p("decidisse quais reducers disparar"),Ja=p(". Assim, deixaríamos o\n    redux livre para fazer seu trabalho de gerenciar o estado da aplicação e\n    lidar com eventos, enquanto os componentes focariam em renderizar coisas -\n    "),Qa=m("strong"),Va=p("somente"),Ka=p("\n    renderizar coisas. Estou falando sobre algo como isso aqui:"),Wa=u(),Xa=m("ul"),Ya=m("li"),Za=p("Componente monta e levanta sinal de iniciar a requisição pro Redux"),eo=u(),ao=m("li"),oo=p("Action do Redux descreve reducers de sucesso e falha e declara função que\n      faz a requisição"),so=u(),ro=m("li"),no=m("strong"),io=p("Middleware chama a função da requisição, guarda a promise e\n        dispara reducer de isLoading"),to=u(),co=m("li"),uo=p("Componente renderiza isLoading"),mo=u(),po=m("li"),lo=m("strong"),fo=p("Middleware escuta a requisição e chama reducer de sucesso ou falha\n        baseado na descrição da action"),go=u(),vo=m("li"),ho=p("Reducer de sucesso ou falha executa código de lógica de negócio e persiste\n      dados na store"),qo=u(),Eo=m("li"),xo=p("Componente renderiza sucesso ou falha"),Ro=u(),bo=m("p"),$o=p("Com esse fluxo proposto, nossas actions poderiam ser mais ou menos assim:"),Po=u(),c(So.$$.fragment),Co=u(),zo=m("p"),Io=p("Ok, vamos com calma. O que você está vendo aí em cima é a nossa convenção\n    atual que descreve uma\n    "),Oo=m("em"),Lo=p("action de requisição"),wo=p(", que usa o middleware incluído no nosso pacote\n    npm\n    "),To=m("a"),Do=m("code"),Ao=p("react-redux-api-tools"),jo=p(". Fazer o dispatch\n    dessa action\n    "),No=m("strong"),Go=p("configura"),Uo=p("\n    o middleware para\n    "),ko=m("strong"),Mo=p("fazer a requisição"),Fo=p("\n    (ao chamar a\n    "),Ho=m("code"),_o=p("apiCallFunction"),yo=p(") e para\n    "),Bo=m("strong"),Jo=p("usar o reducer correto"),Qo=p("\n    assim que a requisição estiver concluída. Enquanto isso, nossos componentes\n    e reducers se manteriam inalterados:"),Vo=u(),c(Ko.$$.fragment),Wo=u(),c(Xo.$$.fragment),Yo=u(),Zo=m("p"),es=p("E\n    "),as=m("em"),os=p("voilá,"),ss=p("\n    nosso fluxo está bem mais limpo, simples e desacoplado!"),rs=u(),ns=m("h2"),is=p("Se você gostou disso ou isso parece mágico demais…"),ts=u(),ds=m("p"),cs=p("Gostou na API desse middleware? Quer desenvolver seus projetos react-redux\n    dessa maneira? Está curiosa para saber como tudo isso funciona por baixo dos\n    panos? Então você é uma pessoa que poderia usar e contribuir com nosso\n    pacote npm\n    "),us=m("a"),ms=p("react-redux-api-tools"),ps=p(".\n    Reportagem de bugs e sugestões de features são bem vindas! E isso tudo é só\n    o começo;\n    "),ls=m("a"),fs=p("react-redux-api-tools"),gs=p("\n    traz um monte de outras features que não consegui descrever nesse post. Dê\n    uma boa olhada na nossa documentação para descobrir como melhorar e\n    simplificar seu código usando nossas ferramentas! Obrigado, e até a próxima!"),this.h()},l:function(e){var d=l('[data-svelte="svelte-e26my1"]',document.head);f(a.$$.fragment,d),d.forEach(g),o=v(e),s=h(e,"H1",{});var c=q(s);r=h(c,"MARK",{});var u=q(r);n=E(u,"Desacoplando a lógica de componentes React"),u.forEach(g),c.forEach(g),i=v(e),f(t.$$.fragment,e),I=v(e),A=h(e,"FIGURE",{});var m=q(A);j=h(m,"IMG",{src:!0,alt:!0}),m.forEach(g),G=v(e),U=h(e,"P",{});var p=q(U);k=h(p,"EM",{});var x=q(k);M=E(x,"for native english speakers,\n    "),F=h(x,"A",{href:!0});var R=q(F);H=E(R,"here's the translated\n      post"),R.forEach(g),x.forEach(g),p.forEach(g),_=v(e),y=h(e,"ARTICLE",{});var b=q(y);B=h(b,"P",{});var $=q(B);J=E($,"Sempre que há um novo projeto baseado em React, grande parte dos devs\n    frontend irão passar pelo ritual de configuração inicial. Padrões de\n    implementação de estilos, desacoplamento de componentes e estrutura de\n    diretórios irão emergir -\n    "),Q=h($,"STRONG",{});var P=q(Q);V=E(P,"nem sempre pro bem"),P.forEach(g),K=E($,". O pior é que todo dev frontend que eu\n    já vi irá resolver o maior problema de todos, o problema de desacoplar\n    lógica de negócio, de uma forma diferente. Em um esforço para criar uma\n    padronização e resolver a questão da camada de domínio aqui na Labcodes, eu\n    pesquisei um bocado e achei uma forma boa e sustentável para lidar com\n    requisições e processamento de dados. O resultado: react-redux-api-tools."),$.forEach(g),W=v(b),X=h(b,"H2",{});var S=q(X);Y=E(S,"Vamos imaginar um cenário comum: CRUD"),S.forEach(g),Z=v(b),ee=h(b,"P",{});var C=q(ee);ae=E(C,"Já que o javascript é muito permissivo, há inúmeras maneiras de\n    implementarmos um CRUD em uma SPA. Se limitarmos o escopo ao uso do react,\n    as coisas ficam mais fáceis, mas ainda há possíveis implementações demais.\n    Uma delas é de usar os hooks de ciclo de vida para fazer as requisições. Seu\n    código provavelmente irá ficar parecido com isso:"),C.forEach(g),oe=v(b),f(se.$$.fragment,b),re=v(b),ne=h(b,"P",{});var z=q(ne);ie=E(z,"Eu acho que não preciso falar muito sobre isso, mas vou falar de qualquer\n    forma: essa implementação, mesmo sendo perfeitamente válida, tem alguns\n    "),te=h(z,"STRONG",{});var O=q(te);de=E(O,"grandes"),O.forEach(g),ce=E(z,"\n    problemas."),z.forEach(g),ue=v(b),me=h(b,"P",{});var L=q(me);pe=E(L,"1.A requisição está sendo feita dentro do componente que, em teoria, deveria\n    ter apenas um trabalho:\n    "),le=h(L,"STRONG",{});var w=q(le);fe=E(w,"renderizar os dados"),w.forEach(g),ge=E(L,". Se, por exemplo, você precisasse\n    limpar a sessão do usuário ou executar qualquer lógica de negócio, ela\n    provavelmente estaria aqui, o que é\n    "),ve=h(L,"STRONG",{});var T=q(ve);he=E(T,"ainda pior"),T.forEach(g),qe=E(L,";"),Ee=h(L,"BR",{}),xe=E(L,"\n    2. Os dados da resposta da requisição está vivendo dentro do estado do\n    componente, e isso significa que tudo será perdido assim que o componente\n    desmontar;"),Re=h(L,"BR",{}),be=E(L,"\n    3. Você terá\n    "),$e=h(L,"STRONG",{});var D=q($e);Pe=E(D,"sempre"),D.forEach(g),Se=E(L,"\n    que pegar os dados da API para cada instância do componente, mesmo que já\n    tenha feito essa específica requisição um bilhão de vezes;"),Ce=h(L,"BR",{}),ze=E(L,"\n    4. Não há nenhum estado intermediário entre o início da requisição e sua\n    resposta, então nada de spinners de loading (apesar de você poder\n    implementar essa lógica construindo um\n    "),Ie=h(L,"EM",{});var N=q(Ie);Oe=E(N,"callback hell"),N.forEach(g),Le=E(L,"\n    de setStates);"),we=h(L,"BR",{}),Te=E(L,"\n    5. Já que componentes react são hierárquicos, se você precisar desses dados\n    dentro de um componente filho ou pai, você terá que implementar\n    contextos/props e callbacks.\n    "),De=h(L,"STRONG",{});var vs=q(De);Ae=E(vs,"O código fica complicado. RAPIDINHO."),vs.forEach(g),je=h(L,"BR",{}),L.forEach(g),Ne=v(b),Ge=h(b,"P",{});var hs=q(Ge);Ue=E(hs,"Para melhorar esse código, muitos de nós preferem usar uma biblioteca para\n    prover um estado mais global para a aplicação; um estado que vive fora de\n    todos os componentes."),hs.forEach(g),ke=v(b),Me=h(b,"H2",{});var qs=q(Me);Fe=E(qs,"Segundo passo: usando Redux"),qs.forEach(g),He=v(b),_e=h(b,"P",{});var Es=q(_e);ye=E(Es,"Redux é uma das melhores bibliotecas para esse tipo de trabalho. Digamos que\n    você vai usar redux para lidar com dados e lógica de negócio. Assumindo que\n    você usará a camada de reducers para formatar dados e chamar lógicas de\n    domínio, seu componente vai ficar mais ou menos assim:"),Es.forEach(g),Be=v(b),f(Je.$$.fragment,b),Qe=v(b),Ve=h(b,"P",{});var xs=q(Ve);Ke=E(xs,"Isso resolve grande parte dos problemas, mas eu diria que essa solução\n    acopla ainda mais o código e, certeza, deixa ele mais difícil de ler e\n    manter. A causa raiz disso tudo é o fato de que o componente está sendo\n    responsável por absolutamente tudo: pegar os dados da API e orquestrar\n    eventos do redux, quando era para ele estar… renderizando coisas. O fluxo\n    ideal para resolver todos os problemas, pelo menos os mais importantes,\n    seria algo similar a isso:"),xs.forEach(g),We=v(b),Xe=h(b,"UL",{class:!0});var Rs=q(Xe);Ye=h(Rs,"LI",{});var bs=q(Ye);Ze=E(bs,"Componente monta e levanta sinal de isLoading pro Redux"),bs.forEach(g),ea=v(Rs),aa=h(Rs,"LI",{});var $s=q(aa);oa=E($s,"Action do Redux começa a requisição e dispara reducer de isLoading"),$s.forEach(g),sa=v(Rs),ra=h(Rs,"LI",{});var Ps=q(ra);na=E(Ps,"Componente renderiza isLoading"),Ps.forEach(g),ia=v(Rs),ta=h(Rs,"LI",{});var Ss=q(ta);da=E(Ss,"Requisição termina assincronamente e dispara reducer de sucesso ou falha"),Ss.forEach(g),ca=v(Rs),ua=h(Rs,"LI",{});var Cs=q(ua);ma=E(Cs,"Componente renderiza sucesso ou falha"),Cs.forEach(g),Rs.forEach(g),pa=v(b),la=h(b,"P",{});var zs=q(la);fa=E(zs,"Note que a única forma de completamente remover a lógica de negócio dos\n    componentes é acionando os casos de uso de ‘Sucesso’ e ‘Falha’\n    "),ga=h(zs,"STRONG",{});var Is=q(ga);va=E(Is,"fora do componente"),Is.forEach(g),ha=E(zs,". Componentes devem renderizar coisas,\n    não lidar com gerenciamento de estado da\n    "),qa=h(zs,"STRONG",{});var Os=q(qa);Ea=E(Os,"aplicação inteira"),Os.forEach(g),xa=E(zs,". Isso significa que o componente apenas\n    deve avisar a alguém que precisa de dados, disparando um evento (o evento de\n    ‘pega esses dados pra mim’), e então reagir aos dados quando eles estiverem\n    lá. Para respeitar essa ideia, nosso código do componente deveria ser tão\n    simples quanto isso:"),zs.forEach(g),Ra=v(b),f(ba.$$.fragment,b),$a=v(b),Pa=h(b,"P",{});var Ls=q(Pa);Sa=E(Ls,"E isso significa que… as actions devem fazer a requisição dos dados? E\n    reducers iriam disparar outras ações? Soa estranho, né? Porque é. E não é o\n    que eu estou sugerindo\n    "),Ca=h(Ls,"STRONG",{});var ws=q(Ca);za=E(ws,"mesmo"),ws.forEach(g),Ia=E(Ls,"."),Ls.forEach(g),Oa=v(b),La=h(b,"H2",{});var Ts=q(La);wa=E(Ts,"Eis que chegam os middlewares"),Ts.forEach(g),Ta=v(b),Da=h(b,"P",{});var Ds=q(Da);Aa=E(Ds,"Para entregarmos o fluxo ideal de dados,\n    "),ja=h(Ds,"STRONG",{});var As=q(ja);Na=E(As,"middlewares do redux são maravilhosos"),As.forEach(g),Ga=E(Ds,". Imaginem que\n    queremos que nosso componente seja exatamente como o código que vimos acima.\n    Se nós, por exemplo, tivéssemos algo entre as actions e os reducers, a gente\n    conseguiria fazer com que esse\n    "),Ua=h(Ds,"EM",{});var js=q(Ua);ka=E(js,"código do meio"),js.forEach(g),Ma=v(Ds),Fa=h(Ds,"STRONG",{});var Ns=q(Fa);Ha=E(Ns,"fizesse a requisição"),Ns.forEach(g),_a=E(Ds,"\n    e, dependendo do resultado,\n    "),ya=h(Ds,"STRONG",{});var Gs=q(ya);Ba=E(Gs,"decidisse quais reducers disparar"),Gs.forEach(g),Ja=E(Ds,". Assim, deixaríamos o\n    redux livre para fazer seu trabalho de gerenciar o estado da aplicação e\n    lidar com eventos, enquanto os componentes focariam em renderizar coisas -\n    "),Qa=h(Ds,"STRONG",{});var Us=q(Qa);Va=E(Us,"somente"),Us.forEach(g),Ka=E(Ds,"\n    renderizar coisas. Estou falando sobre algo como isso aqui:"),Ds.forEach(g),Wa=v(b),Xa=h(b,"UL",{class:!0});var ks=q(Xa);Ya=h(ks,"LI",{});var Ms=q(Ya);Za=E(Ms,"Componente monta e levanta sinal de iniciar a requisição pro Redux"),Ms.forEach(g),eo=v(ks),ao=h(ks,"LI",{});var Fs=q(ao);oo=E(Fs,"Action do Redux descreve reducers de sucesso e falha e declara função que\n      faz a requisição"),Fs.forEach(g),so=v(ks),ro=h(ks,"LI",{});var Hs=q(ro);no=h(Hs,"STRONG",{});var _s=q(no);io=E(_s,"Middleware chama a função da requisição, guarda a promise e\n        dispara reducer de isLoading"),_s.forEach(g),Hs.forEach(g),to=v(ks),co=h(ks,"LI",{});var ys=q(co);uo=E(ys,"Componente renderiza isLoading"),ys.forEach(g),mo=v(ks),po=h(ks,"LI",{});var Bs=q(po);lo=h(Bs,"STRONG",{});var Js=q(lo);fo=E(Js,"Middleware escuta a requisição e chama reducer de sucesso ou falha\n        baseado na descrição da action"),Js.forEach(g),Bs.forEach(g),go=v(ks),vo=h(ks,"LI",{});var Qs=q(vo);ho=E(Qs,"Reducer de sucesso ou falha executa código de lógica de negócio e persiste\n      dados na store"),Qs.forEach(g),qo=v(ks),Eo=h(ks,"LI",{});var Vs=q(Eo);xo=E(Vs,"Componente renderiza sucesso ou falha"),Vs.forEach(g),ks.forEach(g),Ro=v(b),bo=h(b,"P",{});var Ks=q(bo);$o=E(Ks,"Com esse fluxo proposto, nossas actions poderiam ser mais ou menos assim:"),Ks.forEach(g),Po=v(b),f(So.$$.fragment,b),Co=v(b),zo=h(b,"P",{});var Ws=q(zo);Io=E(Ws,"Ok, vamos com calma. O que você está vendo aí em cima é a nossa convenção\n    atual que descreve uma\n    "),Oo=h(Ws,"EM",{});var Xs=q(Oo);Lo=E(Xs,"action de requisição"),Xs.forEach(g),wo=E(Ws,", que usa o middleware incluído no nosso pacote\n    npm\n    "),To=h(Ws,"A",{href:!0,target:!0,rel:!0});var Ys=q(To);Do=h(Ys,"CODE",{});var Zs=q(Do);Ao=E(Zs,"react-redux-api-tools"),Zs.forEach(g),Ys.forEach(g),jo=E(Ws,". Fazer o dispatch\n    dessa action\n    "),No=h(Ws,"STRONG",{});var er=q(No);Go=E(er,"configura"),er.forEach(g),Uo=E(Ws,"\n    o middleware para\n    "),ko=h(Ws,"STRONG",{});var ar=q(ko);Mo=E(ar,"fazer a requisição"),ar.forEach(g),Fo=E(Ws,"\n    (ao chamar a\n    "),Ho=h(Ws,"CODE",{});var or=q(Ho);_o=E(or,"apiCallFunction"),or.forEach(g),yo=E(Ws,") e para\n    "),Bo=h(Ws,"STRONG",{});var sr=q(Bo);Jo=E(sr,"usar o reducer correto"),sr.forEach(g),Qo=E(Ws,"\n    assim que a requisição estiver concluída. Enquanto isso, nossos componentes\n    e reducers se manteriam inalterados:"),Ws.forEach(g),Vo=v(b),f(Ko.$$.fragment,b),Wo=v(b),f(Xo.$$.fragment,b),Yo=v(b),Zo=h(b,"P",{});var rr=q(Zo);es=E(rr,"E\n    "),as=h(rr,"EM",{});var nr=q(as);os=E(nr,"voilá,"),nr.forEach(g),ss=E(rr,"\n    nosso fluxo está bem mais limpo, simples e desacoplado!"),rr.forEach(g),rs=v(b),ns=h(b,"H2",{});var ir=q(ns);is=E(ir,"Se você gostou disso ou isso parece mágico demais…"),ir.forEach(g),ts=v(b),ds=h(b,"P",{});var tr=q(ds);cs=E(tr,"Gostou na API desse middleware? Quer desenvolver seus projetos react-redux\n    dessa maneira? Está curiosa para saber como tudo isso funciona por baixo dos\n    panos? Então você é uma pessoa que poderia usar e contribuir com nosso\n    pacote npm\n    "),us=h(tr,"A",{href:!0});var dr=q(us);ms=E(dr,"react-redux-api-tools"),dr.forEach(g),ps=E(tr,".\n    Reportagem de bugs e sugestões de features são bem vindas! E isso tudo é só\n    o começo;\n    "),ls=h(tr,"A",{href:!0});var cr=q(ls);fs=E(cr,"react-redux-api-tools"),cr.forEach(g),gs=E(tr,"\n    traz um monte de outras features que não consegui descrever nesse post. Dê\n    uma boa olhada na nossa documentação para descobrir como melhorar e\n    simplificar seu código usando nossas ferramentas! Obrigado, e até a próxima!"),tr.forEach(g),b.forEach(g),this.h()},h:function(){j.src!==(N=D)&&x(j,"src",N),x(j,"alt","Ilustração com as logos do React e do Redux"),x(F,"href","/en/decoupling-logic-from-react-components/"),x(Xe,"class","callout"),x(Xa,"class","callout"),x(To,"href","https://www.npmjs.com/package/react-redux-api-tools"),x(To,"target","_blank"),x(To,"rel","noopener"),x(us,"href","https://www.npmjs.com/package/react-redux-api-tools"),x(ls,"href","https://www.npmjs.com/package/react-redux-api-tools")},m:function(d,c){R(a,document.head,null),b(d,o,c),b(d,s,c),$(s,r),$(r,n),b(d,i,c),R(t,d,c),b(d,I,c),b(d,A,c),$(A,j),b(d,G,c),b(d,U,c),$(U,k),$(k,M),$(k,F),$(F,H),b(d,_,c),b(d,y,c),$(y,B),$(B,J),$(B,Q),$(Q,V),$(B,K),$(y,W),$(y,X),$(X,Y),$(y,Z),$(y,ee),$(ee,ae),$(y,oe),R(se,y,null),$(y,re),$(y,ne),$(ne,ie),$(ne,te),$(te,de),$(ne,ce),$(y,ue),$(y,me),$(me,pe),$(me,le),$(le,fe),$(me,ge),$(me,ve),$(ve,he),$(me,qe),$(me,Ee),$(me,xe),$(me,Re),$(me,be),$(me,$e),$($e,Pe),$(me,Se),$(me,Ce),$(me,ze),$(me,Ie),$(Ie,Oe),$(me,Le),$(me,we),$(me,Te),$(me,De),$(De,Ae),$(me,je),$(y,Ne),$(y,Ge),$(Ge,Ue),$(y,ke),$(y,Me),$(Me,Fe),$(y,He),$(y,_e),$(_e,ye),$(y,Be),R(Je,y,null),$(y,Qe),$(y,Ve),$(Ve,Ke),$(y,We),$(y,Xe),$(Xe,Ye),$(Ye,Ze),$(Xe,ea),$(Xe,aa),$(aa,oa),$(Xe,sa),$(Xe,ra),$(ra,na),$(Xe,ia),$(Xe,ta),$(ta,da),$(Xe,ca),$(Xe,ua),$(ua,ma),$(y,pa),$(y,la),$(la,fa),$(la,ga),$(ga,va),$(la,ha),$(la,qa),$(qa,Ea),$(la,xa),$(y,Ra),R(ba,y,null),$(y,$a),$(y,Pa),$(Pa,Sa),$(Pa,Ca),$(Ca,za),$(Pa,Ia),$(y,Oa),$(y,La),$(La,wa),$(y,Ta),$(y,Da),$(Da,Aa),$(Da,ja),$(ja,Na),$(Da,Ga),$(Da,Ua),$(Ua,ka),$(Da,Ma),$(Da,Fa),$(Fa,Ha),$(Da,_a),$(Da,ya),$(ya,Ba),$(Da,Ja),$(Da,Qa),$(Qa,Va),$(Da,Ka),$(y,Wa),$(y,Xa),$(Xa,Ya),$(Ya,Za),$(Xa,eo),$(Xa,ao),$(ao,oo),$(Xa,so),$(Xa,ro),$(ro,no),$(no,io),$(Xa,to),$(Xa,co),$(co,uo),$(Xa,mo),$(Xa,po),$(po,lo),$(lo,fo),$(Xa,go),$(Xa,vo),$(vo,ho),$(Xa,qo),$(Xa,Eo),$(Eo,xo),$(y,Ro),$(y,bo),$(bo,$o),$(y,Po),R(So,y,null),$(y,Co),$(y,zo),$(zo,Io),$(zo,Oo),$(Oo,Lo),$(zo,wo),$(zo,To),$(To,Do),$(Do,Ao),$(zo,jo),$(zo,No),$(No,Go),$(zo,Uo),$(zo,ko),$(ko,Mo),$(zo,Fo),$(zo,Ho),$(Ho,_o),$(zo,yo),$(zo,Bo),$(Bo,Jo),$(zo,Qo),$(y,Vo),R(Ko,y,null),$(y,Wo),R(Xo,y,null),$(y,Yo),$(y,Zo),$(Zo,es),$(Zo,as),$(as,os),$(Zo,ss),$(y,rs),$(y,ns),$(ns,is),$(y,ts),$(y,ds),$(ds,cs),$(ds,us),$(us,ms),$(ds,ps),$(ds,ls),$(ls,fs),$(ds,gs),e[2](y),vs=!0},p:function(e,a){var o={};2&P(a,1)[0]&&(o.text=e[1]),t.$set(o)},i:function(e){vs||(S(a.$$.fragment,e),S(t.$$.fragment,e),S(se.$$.fragment,e),S(Je.$$.fragment,e),S(ba.$$.fragment,e),S(So.$$.fragment,e),S(Ko.$$.fragment,e),S(Xo.$$.fragment,e),vs=!0)},o:function(e){C(a.$$.fragment,e),C(t.$$.fragment,e),C(se.$$.fragment,e),C(Je.$$.fragment,e),C(ba.$$.fragment,e),C(So.$$.fragment,e),C(Ko.$$.fragment,e),C(Xo.$$.fragment,e),vs=!1},d:function(r){z(a),r&&g(o),r&&g(s),r&&g(i),z(t,r),r&&g(I),r&&g(A),r&&g(G),r&&g(U),r&&g(_),r&&g(y),z(se),z(Je),z(ba),z(So),z(Ko),z(Xo),e[2](null)}}}function N(e,a,o){var s,r;return e.$$.update=function(){1&e.$$.dirty&&o(1,r=s&&s.textContent)},[s,r,function(e){I[e?"unshift":"push"]((function(){o(0,s=e)}))}]}var G=function(a){e(d,i);var o=A(d);function d(e){var a;return s(this,d),a=o.call(this),r(n(a),e,N,j,t,{}),a}return d}();export default G;
