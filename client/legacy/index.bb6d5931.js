import{_ as e,a as t,b as a,c as n,i as o,d as r,S as s,s as i,J as h,B as c,K as l,L as d,g as u,j as f,C as m,h as g,M as p,q as v,N as w,l as b,o as y}from"./client.b5ae4b81.js";import{c as E,i as k,a as I,b as x,d as T}from"./4-registering-component.61f1b1f9.js";function P(e){var n=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(e){return!1}}();return function(){var o,r=t(e);if(n){var s=t(this).constructor;o=Reflect.construct(r,arguments,s)}else o=r.apply(this,arguments);return a(this,o)}}function A(e){var t,a,n,o,r,s,i,P,A,C,O,R,q,H,D,L,W,S,j,M,B,G,N,F,U,K,z,Y,J,_,Q,V,X,Z,$,ee,te,ae,ne,oe,re,se,ie,he,ce,le,de,ue,fe,me,ge,pe,ve,we,be,ye,Ee,ke,Ie,xe,Te,Pe,Ae,Ce,Oe,Re,qe,He,De,Le,We,Se,je,Me,Be,Ge,Ne,Fe,Ue,Ke,ze,Ye,Je,_e,Qe,Ve,Xe,Ze,$e,et,tt,at,nt,ot,rt,st,it,ht,ct,lt,dt,ut,ft,mt,gt,pt,vt,wt,bt,yt,Et,kt,It,xt,Tt,Pt,At,Ct,Ot,Rt,qt,Ht,Dt,Lt,Wt,St,jt,Mt,Bt,Gt,Nt,Ft,Ut,Kt,zt,Yt,Jt,_t,Qt,Vt,Xt,Zt,$t,ea,ta,aa,na,oa,ra,sa,ia,ha,ca,la,da,ua,fa,ma,ga,pa,va,wa,ba,ya,Ea,ka,Ia,xa,Ta,Pa,Aa,Ca,Oa,Ra,qa;return{c:function(){t=h("meta"),a=h("meta"),n=c(),o=h("h1"),r=h("mark"),s=l("Keeping global state management sane with rel-events"),i=c(),P=h("p"),A=l("2019-10-19"),C=c(),O=h("figure"),R=h("img"),H=c(),D=h("p"),L=l("Maintaining a big and complex react app is not for amateurs. Whatever you may\n  choose to manage your app state, chances are that it's hard to pick up, like\n  redux, or really convoluted, like making yourself a service layer. With the\n  goal of making it easy for new developers to jump into our projects, we at\n  Labcodes decided it was time to give this problem a little more thought. Our\n  answer was\n  "),W=h("a"),S=l("rel-events"),j=l("."),M=c(),B=h("h2"),G=l("Why another library to manage states?"),N=c(),F=h("p"),U=h("a"),K=h("img"),z=c(),Y=h("p"),J=l("Whenever I think of making something new and shiny, this xkcd strip comes to\n  haunt me. Believe me, I don't want to be the kind of person that does\n  everything themselves, and that's one of my grievances with the fork\n  mentality. However, it was about time I did something to address a pesky\n  problem I deal with daily: using whatever library to separate business logic\n  from react components."),_=c(),Q=h("p"),V=l("At the end of the day, after much thought, I always end up surrendering and\n  running\n  "),X=h("code"),Z=l("npm install redux react-redux --save"),$=l(". I even shared my basic\n  tools to deal with redux on our\n  "),ee=h("a"),te=h("code"),ae=l("react-redux-api-tools"),ne=l("\n  package."),oe=c(),re=h("p"),se=l("And by no means I hate redux; in fact, I love it. It gets the job done, it's\n  ultra flexible, with low side effects. But let's be frank here: the discomfort\n  of reading\n  "),ie=h("code"),he=l("mapStateToProps"),ce=l("\n  for the first time is\n  "),le=h("strong"),de=l("real"),ue=l(". It took me a long while to properly understand what was\n  going on. Then there are actions, action creators, reducers, dispatches and\n  middlewares, and sagas, and async dispatches; it's neverending."),fe=c(),me=h("p"),ge=l("After those confusing and long first months, things started to get easier, but\n  way,\n  "),pe=h("strong"),ve=l("way"),we=l("\n  too verbose. I always thought that redux felt a lower level tool, and that I\n  was always in need of specifying, step by step, exactly and strictly what and\n  how things should be done. No abstraction at all. A lot of copy and paste,\n  though."),be=c(),ye=h("p"),Ee=l("I came to the conclusion that it would be nice to have all the features I\n  would like in my redux configuration - a proper HTTP request flow, less\n  repetition, meaningful connection between actions and reducers -, without\n  sacrificing anything. I got the green light to develop internally a solution\n  for that:\n  "),ke=h("code"),Ie=l("rel-events"),xe=l("."),Te=c(),Pe=h("h2"),Ae=l("Cool, but what's "),Ce=h("code"),Oe=l("rel-events"),Re=l("?"),qe=c(),He=h("p"),De=h("code"),Le=l("rel-events"),We=l("\n  is a React Events Library that takes the concept of events, present in redux,\n  to a higher level of abstraction. It's a thin layer over redux that enables\n  you to stop thinking about actions, reducers, stores and middlewares, so you\n  can focus on what needs to be done: executing domain logic reactively when\n  events pop up."),Se=c(),je=h("p"),Me=l("To do that, let's imagine a simple scenario: we need to enable a user to log\n  into our app."),Be=c(),Ge=h("p"),Ne=l("You could do the whole request flow inside your components, but\n  "),Fe=h("a"),Ue=l("as\n    we stated on our previous blog post"),Ke=l(", we don't really recommend doing\n  that - it always ends up messy. We could use redux, but then our junior\n  developers would need to pass that\n  "),ze=h("code"),Ye=l("mapStateToProps"),Je=l("\n  hurdle, and sometimes we don't have the luxury of taking our time. We could\n  use sagas, but then redux is back with a vengeance."),_e=c(),Qe=h("p"),Ve=l("Now, forget about actions and reducers and imagine we have an object called\n  LoginEvent. Whenever we call it passing an email and password, things get done\n  and data comes through to the component. Imagine you don't need to know\n  anything but its name. No reducers, no actions, no\n  "),Xe=h("code"),Ze=l("connect"),$e=l("\n  or\n  "),et=h("code"),tt=l("mapStateToProps"),at=l(". It would be something like this:"),nt=c(),ot=h("figure"),rt=h("img"),it=c(),ht=h("p"),ct=l("Cool, but what about the whole behavior? Where's the logic to make the\n  request? How to deal with bad requests? Let's say, besides the Event, we have\n  something that manages the event flow, an Event Manager:"),lt=c(),dt=h("figure"),ut=h("img"),mt=c(),gt=h("p"),pt=l("That's better. But how is this manager implemented? Because, if it needs to\n  deal with the event flow, it needs to do a lot of stuff: know how to make the\n  request and what to do when the request succeeds or fails. Oh, and we need an\n  intermediary state, because we love loading spinners! Hell, I forgot about the\n  inital state of the event as well! Ok, ok, let's see:"),vt=c(),wt=h("figure"),bt=h("img"),Et=c(),kt=h("p"),It=l("That's about it, right? But, hey, how do we trigger it? And how do I make the\n  Event register which Components are able to trigger it? How does the component\n  get the data from it? We're almost there:"),xt=c(),Tt=h("figure"),Pt=h("img"),Ct=c(),Ot=h("p"),Rt=l("And that's exactly the current API for a HTTPEvent from\n  "),qt=h("code"),Ht=l("rel-events"),Dt=l(". No actions, no reducers, no coupling between the\n  logic and the component layers, nothing. Of course, it needs some\n  configuration to hook it up with redux, but it's mostly a one time setup, very\n  well documented\n  "),Lt=h("a"),Wt=l("in our docs"),St=l("."),jt=c(),Mt=h("h2"),Bt=l("That sounds... nice! But what about features? I want features!"),Gt=c(),Nt=h("p"),Ft=l("With our current beta version (0.1.3 as of September 2019), you're able to:"),Ut=c(),Kt=h("ul"),zt=h("li"),Yt=l("use a basic Event type (for the times you don't need to make HTTP requests);"),Jt=c(),_t=h("li"),Qt=l("chain Events/HTTPEvents (useful for fetching more data when a request is\n    done);"),Vt=c(),Xt=h("li"),Zt=l("have multiple Events registering to the same Component (you'll probably have\n    a Component that needs to listen to multiple Events);"),$t=c(),ea=h("li"),ta=l("execute code after dispatching an Event (with\n    "),aa=h("code"),na=l("afterDispatch"),oa=l(");"),ra=c(),sa=h("li"),ia=l("execute code after a request is successful (with\n    "),ha=h("code"),ca=l("afterSuccess"),la=l(");"),da=c(),ua=h("li"),fa=l("execute code after a request has failed (with\n    "),ma=h("code"),ga=l("afterFailure"),pa=l(");"),va=c(),wa=h("li"),ba=l("evaluate if an event should be dispatched or not (with the\n    "),ya=h("code"),Ea=l("shouldDispatch"),ka=l("\n    method)."),Ia=c(),xa=h("p"),Ta=l("And more! All that without the cognitive burden, the crazy constants, the\n  store names and all the bad developer experience from redux. The best part: no\n  huge learning curve. This post has basically all you need to know to use our\n  lib. Really."),Pa=c(),Aa=h("p"),Ca=l("So if you liked it,\n  "),Oa=h("a"),Ra=l("take a look at our github\n    repo"),qa=l("\n  to get started and share the love! Thanks for your attention, and see you next\n  time!"),this.h()},l:function(e){var h=d('[data-svelte="svelte-18ccvxm"]',document.head);t=u(h,"META",{name:!0,content:!0}),a=u(h,"META",{name:!0,content:!0}),h.forEach(f),n=m(e),o=u(e,"H1",{});var c=g(o);r=u(c,"MARK",{});var l=g(r);s=p(l,"Keeping global state management sane with rel-events"),l.forEach(f),c.forEach(f),i=m(e),P=u(e,"P",{class:!0});var v=g(P);A=p(v,"2019-10-19"),v.forEach(f),C=m(e),O=u(e,"FIGURE",{});var w=g(O);R=u(w,"IMG",{src:!0,alt:!0}),w.forEach(f),H=m(e),D=u(e,"P",{});var b=g(D);L=p(b,"Maintaining a big and complex react app is not for amateurs. Whatever you may\n  choose to manage your app state, chances are that it's hard to pick up, like\n  redux, or really convoluted, like making yourself a service layer. With the\n  goal of making it easy for new developers to jump into our projects, we at\n  Labcodes decided it was time to give this problem a little more thought. Our\n  answer was\n  "),W=u(b,"A",{href:!0});var y=g(W);S=p(y,"rel-events"),y.forEach(f),j=p(b,"."),b.forEach(f),M=m(e),B=u(e,"H2",{});var E=g(B);G=p(E,"Why another library to manage states?"),E.forEach(f),N=m(e),F=u(e,"P",{});var k=g(F);U=u(k,"A",{href:!0});var I=g(U);K=u(I,"IMG",{src:!0,alt:!0}),I.forEach(f),k.forEach(f),z=m(e),Y=u(e,"P",{});var x=g(Y);J=p(x,"Whenever I think of making something new and shiny, this xkcd strip comes to\n  haunt me. Believe me, I don't want to be the kind of person that does\n  everything themselves, and that's one of my grievances with the fork\n  mentality. However, it was about time I did something to address a pesky\n  problem I deal with daily: using whatever library to separate business logic\n  from react components."),x.forEach(f),_=m(e),Q=u(e,"P",{});var T=g(Q);V=p(T,"At the end of the day, after much thought, I always end up surrendering and\n  running\n  "),X=u(T,"CODE",{});var q=g(X);Z=p(q,"npm install redux react-redux --save"),q.forEach(f),$=p(T,". I even shared my basic\n  tools to deal with redux on our\n  "),ee=u(T,"A",{href:!0});var st=g(ee);te=u(st,"CODE",{});var ft=g(te);ae=p(ft,"react-redux-api-tools"),ft.forEach(f),st.forEach(f),ne=p(T,"\n  package."),T.forEach(f),oe=m(e),re=u(e,"P",{});var yt=g(re);se=p(yt,"And by no means I hate redux; in fact, I love it. It gets the job done, it's\n  ultra flexible, with low side effects. But let's be frank here: the discomfort\n  of reading\n  "),ie=u(yt,"CODE",{});var At=g(ie);he=p(At,"mapStateToProps"),At.forEach(f),ce=p(yt,"\n  for the first time is\n  "),le=u(yt,"STRONG",{});var Ha=g(le);de=p(Ha,"real"),Ha.forEach(f),ue=p(yt,". It took me a long while to properly understand what was\n  going on. Then there are actions, action creators, reducers, dispatches and\n  middlewares, and sagas, and async dispatches; it's neverending."),yt.forEach(f),fe=m(e),me=u(e,"P",{});var Da=g(me);ge=p(Da,"After those confusing and long first months, things started to get easier, but\n  way,\n  "),pe=u(Da,"STRONG",{});var La=g(pe);ve=p(La,"way"),La.forEach(f),we=p(Da,"\n  too verbose. I always thought that redux felt a lower level tool, and that I\n  was always in need of specifying, step by step, exactly and strictly what and\n  how things should be done. No abstraction at all. A lot of copy and paste,\n  though."),Da.forEach(f),be=m(e),ye=u(e,"P",{});var Wa=g(ye);Ee=p(Wa,"I came to the conclusion that it would be nice to have all the features I\n  would like in my redux configuration - a proper HTTP request flow, less\n  repetition, meaningful connection between actions and reducers -, without\n  sacrificing anything. I got the green light to develop internally a solution\n  for that:\n  "),ke=u(Wa,"CODE",{});var Sa=g(ke);Ie=p(Sa,"rel-events"),Sa.forEach(f),xe=p(Wa,"."),Wa.forEach(f),Te=m(e),Pe=u(e,"H2",{});var ja=g(Pe);Ae=p(ja,"Cool, but what's "),Ce=u(ja,"CODE",{});var Ma=g(Ce);Oe=p(Ma,"rel-events"),Ma.forEach(f),Re=p(ja,"?"),ja.forEach(f),qe=m(e),He=u(e,"P",{});var Ba=g(He);De=u(Ba,"CODE",{});var Ga=g(De);Le=p(Ga,"rel-events"),Ga.forEach(f),We=p(Ba,"\n  is a React Events Library that takes the concept of events, present in redux,\n  to a higher level of abstraction. It's a thin layer over redux that enables\n  you to stop thinking about actions, reducers, stores and middlewares, so you\n  can focus on what needs to be done: executing domain logic reactively when\n  events pop up."),Ba.forEach(f),Se=m(e),je=u(e,"P",{});var Na=g(je);Me=p(Na,"To do that, let's imagine a simple scenario: we need to enable a user to log\n  into our app."),Na.forEach(f),Be=m(e),Ge=u(e,"P",{});var Fa=g(Ge);Ne=p(Fa,"You could do the whole request flow inside your components, but\n  "),Fe=u(Fa,"A",{href:!0});var Ua=g(Fe);Ue=p(Ua,"as\n    we stated on our previous blog post"),Ua.forEach(f),Ke=p(Fa,", we don't really recommend doing\n  that - it always ends up messy. We could use redux, but then our junior\n  developers would need to pass that\n  "),ze=u(Fa,"CODE",{});var Ka=g(ze);Ye=p(Ka,"mapStateToProps"),Ka.forEach(f),Je=p(Fa,"\n  hurdle, and sometimes we don't have the luxury of taking our time. We could\n  use sagas, but then redux is back with a vengeance."),Fa.forEach(f),_e=m(e),Qe=u(e,"P",{});var za=g(Qe);Ve=p(za,"Now, forget about actions and reducers and imagine we have an object called\n  LoginEvent. Whenever we call it passing an email and password, things get done\n  and data comes through to the component. Imagine you don't need to know\n  anything but its name. No reducers, no actions, no\n  "),Xe=u(za,"CODE",{});var Ya=g(Xe);Ze=p(Ya,"connect"),Ya.forEach(f),$e=p(za,"\n  or\n  "),et=u(za,"CODE",{});var Ja=g(et);tt=p(Ja,"mapStateToProps"),Ja.forEach(f),at=p(za,". It would be something like this:"),za.forEach(f),nt=m(e),ot=u(e,"FIGURE",{});var _a=g(ot);rt=u(_a,"IMG",{src:!0,alt:!0}),_a.forEach(f),it=m(e),ht=u(e,"P",{});var Qa=g(ht);ct=p(Qa,"Cool, but what about the whole behavior? Where's the logic to make the\n  request? How to deal with bad requests? Let's say, besides the Event, we have\n  something that manages the event flow, an Event Manager:"),Qa.forEach(f),lt=m(e),dt=u(e,"FIGURE",{});var Va=g(dt);ut=u(Va,"IMG",{src:!0,alt:!0}),Va.forEach(f),mt=m(e),gt=u(e,"P",{});var Xa=g(gt);pt=p(Xa,"That's better. But how is this manager implemented? Because, if it needs to\n  deal with the event flow, it needs to do a lot of stuff: know how to make the\n  request and what to do when the request succeeds or fails. Oh, and we need an\n  intermediary state, because we love loading spinners! Hell, I forgot about the\n  inital state of the event as well! Ok, ok, let's see:"),Xa.forEach(f),vt=m(e),wt=u(e,"FIGURE",{});var Za=g(wt);bt=u(Za,"IMG",{src:!0,alt:!0}),Za.forEach(f),Et=m(e),kt=u(e,"P",{});var $a=g(kt);It=p($a,"That's about it, right? But, hey, how do we trigger it? And how do I make the\n  Event register which Components are able to trigger it? How does the component\n  get the data from it? We're almost there:"),$a.forEach(f),xt=m(e),Tt=u(e,"FIGURE",{});var en=g(Tt);Pt=u(en,"IMG",{src:!0,alt:!0}),en.forEach(f),Ct=m(e),Ot=u(e,"P",{});var tn=g(Ot);Rt=p(tn,"And that's exactly the current API for a HTTPEvent from\n  "),qt=u(tn,"CODE",{});var an=g(qt);Ht=p(an,"rel-events"),an.forEach(f),Dt=p(tn,". No actions, no reducers, no coupling between the\n  logic and the component layers, nothing. Of course, it needs some\n  configuration to hook it up with redux, but it's mostly a one time setup, very\n  well documented\n  "),Lt=u(tn,"A",{href:!0});var nn=g(Lt);Wt=p(nn,"in our docs"),nn.forEach(f),St=p(tn,"."),tn.forEach(f),jt=m(e),Mt=u(e,"H2",{});var on=g(Mt);Bt=p(on,"That sounds... nice! But what about features? I want features!"),on.forEach(f),Gt=m(e),Nt=u(e,"P",{});var rn=g(Nt);Ft=p(rn,"With our current beta version (0.1.3 as of September 2019), you're able to:"),rn.forEach(f),Ut=m(e),Kt=u(e,"UL",{});var sn=g(Kt);zt=u(sn,"LI",{});var hn=g(zt);Yt=p(hn,"use a basic Event type (for the times you don't need to make HTTP requests);"),hn.forEach(f),Jt=m(sn),_t=u(sn,"LI",{});var cn=g(_t);Qt=p(cn,"chain Events/HTTPEvents (useful for fetching more data when a request is\n    done);"),cn.forEach(f),Vt=m(sn),Xt=u(sn,"LI",{});var ln=g(Xt);Zt=p(ln,"have multiple Events registering to the same Component (you'll probably have\n    a Component that needs to listen to multiple Events);"),ln.forEach(f),$t=m(sn),ea=u(sn,"LI",{});var dn=g(ea);ta=p(dn,"execute code after dispatching an Event (with\n    "),aa=u(dn,"CODE",{});var un=g(aa);na=p(un,"afterDispatch"),un.forEach(f),oa=p(dn,");"),dn.forEach(f),ra=m(sn),sa=u(sn,"LI",{});var fn=g(sa);ia=p(fn,"execute code after a request is successful (with\n    "),ha=u(fn,"CODE",{});var mn=g(ha);ca=p(mn,"afterSuccess"),mn.forEach(f),la=p(fn,");"),fn.forEach(f),da=m(sn),ua=u(sn,"LI",{});var gn=g(ua);fa=p(gn,"execute code after a request has failed (with\n    "),ma=u(gn,"CODE",{});var pn=g(ma);ga=p(pn,"afterFailure"),pn.forEach(f),pa=p(gn,");"),gn.forEach(f),va=m(sn),wa=u(sn,"LI",{});var vn=g(wa);ba=p(vn,"evaluate if an event should be dispatched or not (with the\n    "),ya=u(vn,"CODE",{});var wn=g(ya);Ea=p(wn,"shouldDispatch"),wn.forEach(f),ka=p(vn,"\n    method)."),vn.forEach(f),sn.forEach(f),Ia=m(e),xa=u(e,"P",{});var bn=g(xa);Ta=p(bn,"And more! All that without the cognitive burden, the crazy constants, the\n  store names and all the bad developer experience from redux. The best part: no\n  huge learning curve. This post has basically all you need to know to use our\n  lib. Really."),bn.forEach(f),Pa=m(e),Aa=u(e,"P",{});var yn=g(Aa);Ca=p(yn,"So if you liked it,\n  "),Oa=u(yn,"A",{href:!0});var En=g(Oa);Ra=p(En,"take a look at our github\n    repo"),En.forEach(f),qa=p(yn,"\n  to get started and share the love! Thanks for your attention, and see you next\n  time!"),yn.forEach(f),this.h()},h:function(){document.title="\n    Keeping global state management sane with rel-events - luciano@ratamero.com\n  ",v(t,"name","description"),v(t,"content","In this post, we'll discuss how to use rel-events to keep your React app's state sane :]"),v(a,"name","keywords"),v(a,"content","Luciano Ratamero, rel-events, react, redux, big projects, architecture, planning, frontend, javascript, frameworks"),v(P,"class","meta"),R.src!==(q=E)&&v(R,"src",q),v(R,"alt","Logos from React and Redux"),v(W,"href","https://github.com/labcodes/rel-events"),K.src!=="https://imgs.xkcd.com/comics/standards.png"&&v(K,"src","https://imgs.xkcd.com/comics/standards.png"),v(K,"alt","xkcd is always right"),v(U,"href","https://xkcd.com/927/"),v(ee,"href","https://github.com/labcodes/react-redux-api-tools/"),v(Fe,"href","https://labcodes.com.br/blog/en/decoupling-logic-from-react-components.html"),rt.src!==(st=k)&&v(rt,"src",st),v(rt,"alt","Imaginary Event"),ut.src!==(ft=I)&&v(ut,"src",ft),v(ut,"alt","Basic rel-events HTTPEvent"),bt.src!==(yt=x)&&v(bt,"src",yt),v(bt,"alt","LoginEventManager"),Pt.src!==(At=T)&&v(Pt,"src",At),v(Pt,"alt","Registering the component"),v(Lt,"href","https://github.com/labcodes/rel-events/tree/master/docs"),v(Oa,"href","https://github.com/labcodes/rel-events")},m:function(e,h){w(document.head,t),w(document.head,a),b(e,n,h),b(e,o,h),w(o,r),w(r,s),b(e,i,h),b(e,P,h),w(P,A),b(e,C,h),b(e,O,h),w(O,R),b(e,H,h),b(e,D,h),w(D,L),w(D,W),w(W,S),w(D,j),b(e,M,h),b(e,B,h),w(B,G),b(e,N,h),b(e,F,h),w(F,U),w(U,K),b(e,z,h),b(e,Y,h),w(Y,J),b(e,_,h),b(e,Q,h),w(Q,V),w(Q,X),w(X,Z),w(Q,$),w(Q,ee),w(ee,te),w(te,ae),w(Q,ne),b(e,oe,h),b(e,re,h),w(re,se),w(re,ie),w(ie,he),w(re,ce),w(re,le),w(le,de),w(re,ue),b(e,fe,h),b(e,me,h),w(me,ge),w(me,pe),w(pe,ve),w(me,we),b(e,be,h),b(e,ye,h),w(ye,Ee),w(ye,ke),w(ke,Ie),w(ye,xe),b(e,Te,h),b(e,Pe,h),w(Pe,Ae),w(Pe,Ce),w(Ce,Oe),w(Pe,Re),b(e,qe,h),b(e,He,h),w(He,De),w(De,Le),w(He,We),b(e,Se,h),b(e,je,h),w(je,Me),b(e,Be,h),b(e,Ge,h),w(Ge,Ne),w(Ge,Fe),w(Fe,Ue),w(Ge,Ke),w(Ge,ze),w(ze,Ye),w(Ge,Je),b(e,_e,h),b(e,Qe,h),w(Qe,Ve),w(Qe,Xe),w(Xe,Ze),w(Qe,$e),w(Qe,et),w(et,tt),w(Qe,at),b(e,nt,h),b(e,ot,h),w(ot,rt),b(e,it,h),b(e,ht,h),w(ht,ct),b(e,lt,h),b(e,dt,h),w(dt,ut),b(e,mt,h),b(e,gt,h),w(gt,pt),b(e,vt,h),b(e,wt,h),w(wt,bt),b(e,Et,h),b(e,kt,h),w(kt,It),b(e,xt,h),b(e,Tt,h),w(Tt,Pt),b(e,Ct,h),b(e,Ot,h),w(Ot,Rt),w(Ot,qt),w(qt,Ht),w(Ot,Dt),w(Ot,Lt),w(Lt,Wt),w(Ot,St),b(e,jt,h),b(e,Mt,h),w(Mt,Bt),b(e,Gt,h),b(e,Nt,h),w(Nt,Ft),b(e,Ut,h),b(e,Kt,h),w(Kt,zt),w(zt,Yt),w(Kt,Jt),w(Kt,_t),w(_t,Qt),w(Kt,Vt),w(Kt,Xt),w(Xt,Zt),w(Kt,$t),w(Kt,ea),w(ea,ta),w(ea,aa),w(aa,na),w(ea,oa),w(Kt,ra),w(Kt,sa),w(sa,ia),w(sa,ha),w(ha,ca),w(sa,la),w(Kt,da),w(Kt,ua),w(ua,fa),w(ua,ma),w(ma,ga),w(ua,pa),w(Kt,va),w(Kt,wa),w(wa,ba),w(wa,ya),w(ya,Ea),w(wa,ka),b(e,Ia,h),b(e,xa,h),w(xa,Ta),b(e,Pa,h),b(e,Aa,h),w(Aa,Ca),w(Aa,Oa),w(Oa,Ra),w(Aa,qa)},p:y,i:y,o:y,d:function(e){f(t),f(a),e&&f(n),e&&f(o),e&&f(i),e&&f(P),e&&f(C),e&&f(O),e&&f(H),e&&f(D),e&&f(M),e&&f(B),e&&f(N),e&&f(F),e&&f(z),e&&f(Y),e&&f(_),e&&f(Q),e&&f(oe),e&&f(re),e&&f(fe),e&&f(me),e&&f(be),e&&f(ye),e&&f(Te),e&&f(Pe),e&&f(qe),e&&f(He),e&&f(Se),e&&f(je),e&&f(Be),e&&f(Ge),e&&f(_e),e&&f(Qe),e&&f(nt),e&&f(ot),e&&f(it),e&&f(ht),e&&f(lt),e&&f(dt),e&&f(mt),e&&f(gt),e&&f(vt),e&&f(wt),e&&f(Et),e&&f(kt),e&&f(xt),e&&f(Tt),e&&f(Ct),e&&f(Ot),e&&f(jt),e&&f(Mt),e&&f(Gt),e&&f(Nt),e&&f(Ut),e&&f(Kt),e&&f(Ia),e&&f(xa),e&&f(Pa),e&&f(Aa)}}}var C=function(t){e(h,s);var a=P(h);function h(e){var t;return n(this,h),t=a.call(this),o(r(t),e,null,A,i,{}),t}return h}();export default C;
