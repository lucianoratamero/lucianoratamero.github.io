import{S as e,i as a,s as o,M as s,c as r,a as n,e as t,t as i,q as m,j as d,d as c,f as u,b as p,g as l,h as v,k as f,n as g,m as h,l as q,p as b,r as E,u as x,H as $}from"./client.311a5b93.js";import"./Icon.06acf308.js";import{M as P,P as C}from"./MetaTags.39c5eacd.js";import{H as T,j}from"./index.ec9d7c60.js";import{c as z}from"./cover.4038dd1b.js";function L(e){let a,o,$,L,M,S,D,N,O,H,I,A,w,k,R,y,F,G,U,V,Z,J,K,B,Q,W,X,Y,_,ee,ae,oe,se,re,ne,te,ie,me,de,ce,ue,pe,le,ve,fe,ge,he,qe,be,Ee,xe,$e,Pe,Ce,Te,je,ze,Le,Me,Se,De,Ne,Oe,He,Ie,Ae,we,ke,Re,ye,Fe,Ge,Ue,Ve,Ze,Je,Ke,Be,Qe,We,Xe,Ye,_e,ea,aa,oa,sa,ra,na,ta,ia,ma,da,ca,ua,pa,la,va,fa,ga,ha,qa,ba,Ea,xa,$a,Pa,Ca,Ta,ja,za,La,Ma,Sa,Da,Na,Oa,Ha,Ia,Aa,wa,ka,Ra,ya,Fa,Ga,Ua,Va,Za,Ja,Ka,Ba,Qa,Wa,Xa,Ya,_a,eo,ao,oo,so,ro,no,to,io,mo,co,uo,po,lo,vo,fo,go,ho,qo,bo,Eo,xo,$o,Po,Co,To,jo,zo,Lo,Mo,So,Do,No,Oo,Ho,Io,Ao,wo;return a=new P({props:{title:"Mantendo o estado global de uma maneira sã com rel-events",description:"Nesse post, discutiremos como usar a rel-events para lidar com o estado global de sua app React de uma maneira mais fácil e sã :]",keywords:"rel-events, react, redux, grandes projetos, arquitetura, planejamento, frontend, javascript, frameworks"}}),D=new C({props:{date:"2019-09-19",text:e[1]}}),ga=new T({props:{language:j,code:s('\nimport { HTTPEvent } from "rel-events";\n\nexport const LoginEvent = new HTTPEvent({ name: "login" });\n')}}),xa=new T({props:{language:j,code:s('\nimport { HTTPEvent } from "rel-events";\nimport { LoginEventManager } from "./eventManagers";\n\nexport const LoginEvent = new HTTPEvent({\n  name: "login",\n  manager: new LoginEventManager(),\n});\n')}}),ja=new T({props:{language:j,code:s('\nimport { fetchFromApi } from "rel-events";\n\nexport class LoginEventManager {\n  initialState = { isLoading: false, username: "Anonymous" };\n\n  call = (user) => {\n    return () => fetchFromApi(\n      "/api/login",\n      { method: "POST", body: JSON.stringify(user) }\n    );\n  }\n\n  onDispatch = (state, event) => ({\n    ...state,\n    isLoading: true,\n    username: this.initialState.username\n  })\n\n  onSuccess = (state, event) => ({\n    ...state,\n    isLoading: this.initialState.isLoading,\n    username: event.response.data.username\n  })\n\n  onFailure = (state, event) => ({\n    ...state,\n    isLoading: this.initialState.isLoading,\n    username: this.initialState.username,\n    error: event.error.data\n  })\n});\n')}}),Da=new T({props:{language:j,code:s('\n// LoginComponent.js\nimport React from "react";\nimport { LoginEvent } from "./events";\n\nexport class LoginComponent extends React.Component {\n  handleSubmit = () => {\n    const { user } = this.state;\n    // o Evento injeta seu gatilho como prop, com o mesmo nome do Evento ("login")\n    const { login } = this.props;\n\n    login(user);\n  }\n\n  render() {\n    const { username } = this.props;\n    return (\n      <React.Fragment>\n        <h1>Hello, {username}</h1>\n        <form>{ /* inputs e botão de submit */ }</form>\n      </React.Fragment>\n    );\n  }\n});\n\n// e aqui, registramos o Componente no Evento,\n// que injeta o gatilho como descrito acima\n// e também pedimos que o valor de "username" do Evento seja injetado como prop\nexport default LoginEvent.register({\n  Component: LoginComponent,\n  props: ["username"]\n});\n')}}),{c(){r(a.$$.fragment),o=n(),$=t("h1"),L=t("mark"),M=i("Mantendo o estado global de uma maneira sã com rel-events"),S=n(),r(D.$$.fragment),N=n(),O=t("article"),H=t("figure"),I=t("img"),w=n(),k=t("p"),R=t("em"),y=i("for native english speakers,\n      "),F=t("a"),G=i("here's\n        the translated post"),U=n(),V=t("p"),Z=i("Manter uma aplicação react grande e complexa não é um trabalho pra amadores.\n    Não importa o que você escolher para lidar com a máquina de estados da\n    aplicação, é quase certo de que é algo difícil de aprender, como redux, ou\n    realmente complicado, como fazer uma camada de serviços na mão. Com o\n    objetivo de fazer com que novas pessoas possam entrar fácil nos projetos, a\n    galera da Labcodes decidiu que tava na hora de dar mais atenção e uma\n    verdadeira solução pra esse tipo de problema. Nossa resposta foi criar a\n    biblioteca\n    "),J=t("a"),K=i("rel-events"),B=i("."),Q=n(),W=t("h2"),X=i("Pra que mais uma biblioteca para gerenciar estado?"),Y=n(),_=t("p"),ee=t("a"),ae=t("img"),se=n(),re=t("p"),ne=i("Sempre que eu penso em criar uma biblioteca nova, essa tirinha do xkcd vem\n    me assombrar. Acreditem, eu não quero ser o tipo de pessoa que faz tudo por\n    conta própria em vez de contribuir com algo que já existe, e esse é um dos\n    problemas com essa mentalidade de forkar tudo. No entanto, eu sempre quis\n    resolver um problema com o qual eu lido diariamente: usar uma biblioteca\n    qualquer pra separar lógica de negócio/domínio dos meus componentes react."),te=n(),ie=t("p"),me=i("Mas no fim do dia, depois de pensar muito, acabo me rendendo e rodando o\n    clássico\n    "),de=t("code"),ce=i("npm install redux react-redux --save"),ue=i(". Eu até compartilhei\n    algumas das ferramentas que eu uso com redux na nossa outra lib\n    "),pe=t("a"),le=t("code"),ve=i("react-redux-api-tools"),fe=i("."),ge=n(),he=t("p"),qe=i("Não ache que eu odeio o redux; pelo contrário, eu amo. Ele cumpre sua\n    função, é ultra flexível, com poucos efeitos colaterais. Mas vamos ser\n    sinceros: o desconforto quando lemos\n    "),be=t("code"),Ee=i("mapStateToProps"),xe=i("\n    pela primeira vez é\n    "),$e=t("strong"),Pe=i("real"),Ce=i(". Demorei um bom tempo pra entender o que tava\n    acontecendo de verdade. E ainda tem actions, action creators, reducers,\n    dispatches e middlewares, e sagas, e async dispatches; o aprendizado nunca\n    acaba."),Te=n(),je=t("p"),ze=i("Depois dos primeiros confusos meses, lidar com o redux fica mais fácil (como\n    quase tudo na vida), mas muito,\n    "),Le=t("strong"),Me=i("muito"),Se=i("\n    mais verboso. Eu sempre pensei que o redux parecia uma biblioteca muito\n    baixo nível e que eu sempre sou obrigado a especificar, passo a passo,\n    exatamente e estritamente o que precisa ser feito. Zero abstração. E muita\n    cópia e cola."),De=n(),Ne=t("p"),Oe=i("Cheguei à conclusão de que seria ótimo ter todas as features que gosto na\n    minha configuração do redux - um fluxo para HTTP bem definido, menos\n    repetição, conexão semântica entre actions e reducers -, sem sacrificar\n    nada. Daí me deram a luz verde pra desenvolver internamente uma solução pra\n    isso:\n    "),He=t("code"),Ie=i("rel-events"),Ae=i("."),we=n(),ke=t("h2"),Re=i("Legal, mas o que raios é "),ye=t("code"),Fe=i("rel-events"),Ge=i("?"),Ue=n(),Ve=t("p"),Ze=t("code"),Je=i("rel-events"),Ke=i("\n    é uma biblioteca de eventos para react (React Events Library, por isso rel\n    ;]). Ela leva o conceito de eventos, que já existe no redux, pra um nível\n    mais alto de abstração. É uma camada fina por cima do redux que permite que\n    você pare de pensar em actions, reducers, stores e middlewares, pra que você\n    possa focar no que precisa ser feito, que é executar lógica de negócio de\n    forma reativa quando eventos acontecem."),Be=n(),Qe=t("p"),We=i("Pra isso, vou propor que a gente imagine um cenário bem comum: precisamos\n    fazer com que um usuário faça login na nossa aplicação."),Xe=n(),Ye=t("p"),_e=i("Nós poderíamos fazer todo o fluxo de requisições dentro dos próprios\n    componentes, mas\n    "),ea=t("a"),aa=i("como\n      dissemos no nosso outro post"),oa=i(", nós não exatamente recomendamos esse\n    caminho - sempre termina com código macarronado. Nós poderíamos usar redux,\n    mas aí nossos devs juniors precisariam antes passar pela barreira do\n    "),sa=t("code"),ra=i("mapStateToProps"),na=i(", e às vezes nós não temos tempo de falar sobre\n    absolutamente tudo de redux antes de entregar nossos projetos. Nós\n    poderíamos usar sagas, mas aí o redux volta pra nos atazanar em dobro."),ta=n(),ia=t("p"),ma=i("Então, vamos por uns minutos esquecer de actions e reducers e imaginemos um\n    objeto chamado LoginEvent. Sempre que executamos algo sobre esse objeto\n    passando email e senha, coisas acontecem e os dados corretos (de sucesso ou\n    falha do login) são passados pros componentes. Imagine que você não precise\n    saber nada sobre esse objeto, apenas seu nome. Sem reducers, sem actions,\n    sem\n    "),da=t("code"),ca=i("connect"),ua=i("\n    ou\n    "),pa=t("code"),la=i("mapStateToProps"),va=i(". Seria algo mais ou menos assim:"),fa=n(),r(ga.$$.fragment),ha=n(),qa=t("p"),ba=i("Legal, mas onde colocaríamos todo seu comportamento? Onde tá o código que\n    faz a requisição? Como lidar com casos de erro? Digamos que, além do objeto\n    de evento, nós tenhamos algo que gerencia todo o fluxo do evento, que\n    chamaríamos de Event Manager:"),Ea=n(),r(xa.$$.fragment),$a=n(),Pa=t("p"),Ca=i("Melhor. Mas como esse manager tá implementado? Porque, se a gente precisa\n    lidar com o fluxo inteiro dentro dele, ele precisa saber de muita coisa:\n    como fazer a requisição, por exemplo, ou o que fazer com o estado global\n    quando a requisição tiver sucesso ou falha. Ah, e seria bom ter um estado\n    intermediário quando a requisição começa, porque a gente ama spinners de\n    loading! Eita, esqueci que eu preciso de um estado inicial pra esse evento\n    também, pra gente ter dados antes mesmo da requisição. Calma, calma, vamo\n    lá:"),Ta=n(),r(ja.$$.fragment),za=n(),La=t("p"),Ma=i("É mais ou menos isso que a gente precisa, né? Mas então, como que a gente\n    faria pra registrar quais Componentes que poderiam disparar esse Evento?\n    Como que o Componente pegaria os dados desse evento? Tamo quase lá:"),Sa=n(),r(Da.$$.fragment),Na=n(),Oa=t("p"),Ha=i("E essa é exatamente a API atual para um Evento HTTP (HTTPEvent) da lib\n    "),Ia=t("code"),Aa=i("rel-events"),wa=i(". Nada de actions nem reducers, nada de acoplar as\n    camadas de domínio com a de componentes, nada. Claro, a gente precisaria\n    antes configurar como nossa lib se encaixa com o redux, mas geralmente é uma\n    configuração de uma vez só, e muito bem documentada\n    "),ka=t("a"),Ra=i("na nossa\n      documentação (ainda só em inglês, com português em breve"),ya=i(")."),Fa=n(),Ga=t("h2"),Ua=i("Isso parece... bom! Mas e as funcionalidades? Eu quero features!"),Va=n(),Za=t("p"),Ja=i("Na nossa atual versão beta (0.1.3, de Setembro de 2019), você pode:"),Ka=n(),Ba=t("ul"),Qa=t("li"),Wa=i("usar um Evento (Event) básico (pras horas em que você não precisa fazer\n      requisições);"),Xa=n(),Ya=t("li"),_a=i("encadear um Event/HTTPEvent em outro (útil pra quando você quer buscar\n      mais dados depois que um evento teve sucesso);"),eo=n(),ao=t("li"),oo=i("ter múltiplos Events registrados para um mesmo Componente (porque você\n      provavelmente vai ter um Componente que precisa ler dados de vários\n      lugares);"),so=n(),ro=t("li"),no=i("executar código depois das mudanças de estado de um Evento que foi\n      disparado (usando\n      "),to=t("code"),io=i("afterDispatch"),mo=i(");"),co=n(),uo=t("li"),po=i("executar código depois das mudanças de estado de uma requisição que teve\n      sucesso (usando\n      "),lo=t("code"),vo=i("afterSuccess"),fo=i(");"),go=n(),ho=t("li"),qo=i("executar código depois das mudanças de estado de uma requisição que falhou\n      (usando\n      "),bo=t("code"),Eo=i("afterFailure"),xo=i(");"),$o=n(),Po=t("li"),Co=i("avaliar se um evento deve ser disparado ou não (com o método\n      "),To=t("code"),jo=i("shouldDispatch"),zo=i("\n      do EventManager)."),Lo=n(),Mo=t("p"),So=i("E muito mais! Tudo isso sem a carga cognitiva, sem as constantes aleatórias,\n    sem os nomes de store manuais e toda a má experiência de desenvolvimento do\n    redux. E a melhor parte: sem uma grande curva de aprendizado. Esse post tem\n    basicamente tudo que você precisa saber pra usar nossa biblioteca no\n    dia-a-dia. Mesmo. Eu sei, porque tô usando!"),Do=n(),No=t("p"),Oo=i("Então se você gostou,\n    "),Ho=t("a"),Io=i("dá uma olhada no nosso\n      repositório no github"),Ao=i("\n    pra começar a usar e comparilhe o amor! Valeu pela atenção, e eu vejo vocês\n    na próxima!"),this.h()},l(e){const s=m('[data-svelte="svelte-1rtu9ul"]',document.head);d(a.$$.fragment,s),s.forEach(c),o=u(e),$=p(e,"H1",{});var r=l($);L=p(r,"MARK",{});var n=l(L);M=v(n,"Mantendo o estado global de uma maneira sã com rel-events"),n.forEach(c),r.forEach(c),S=u(e),d(D.$$.fragment,e),N=u(e),O=p(e,"ARTICLE",{});var t=l(O);H=p(t,"FIGURE",{});var i=l(H);I=p(i,"IMG",{src:!0,alt:!0}),i.forEach(c),w=u(t),k=p(t,"P",{});var f=l(k);R=p(f,"EM",{});var g=l(R);y=v(g,"for native english speakers,\n      "),F=p(g,"A",{href:!0});var h=l(F);G=v(h,"here's\n        the translated post"),h.forEach(c),g.forEach(c),f.forEach(c),U=u(t),V=p(t,"P",{});var q=l(V);Z=v(q,"Manter uma aplicação react grande e complexa não é um trabalho pra amadores.\n    Não importa o que você escolher para lidar com a máquina de estados da\n    aplicação, é quase certo de que é algo difícil de aprender, como redux, ou\n    realmente complicado, como fazer uma camada de serviços na mão. Com o\n    objetivo de fazer com que novas pessoas possam entrar fácil nos projetos, a\n    galera da Labcodes decidiu que tava na hora de dar mais atenção e uma\n    verdadeira solução pra esse tipo de problema. Nossa resposta foi criar a\n    biblioteca\n    "),J=p(q,"A",{href:!0});var b=l(J);K=v(b,"rel-events"),b.forEach(c),B=v(q,"."),q.forEach(c),Q=u(t),W=p(t,"H2",{});var E=l(W);X=v(E,"Pra que mais uma biblioteca para gerenciar estado?"),E.forEach(c),Y=u(t),_=p(t,"P",{});var x=l(_);ee=p(x,"A",{href:!0});var P=l(ee);ae=p(P,"IMG",{src:!0,alt:!0}),P.forEach(c),x.forEach(c),se=u(t),re=p(t,"P",{});var C=l(re);ne=v(C,"Sempre que eu penso em criar uma biblioteca nova, essa tirinha do xkcd vem\n    me assombrar. Acreditem, eu não quero ser o tipo de pessoa que faz tudo por\n    conta própria em vez de contribuir com algo que já existe, e esse é um dos\n    problemas com essa mentalidade de forkar tudo. No entanto, eu sempre quis\n    resolver um problema com o qual eu lido diariamente: usar uma biblioteca\n    qualquer pra separar lógica de negócio/domínio dos meus componentes react."),C.forEach(c),te=u(t),ie=p(t,"P",{});var T=l(ie);me=v(T,"Mas no fim do dia, depois de pensar muito, acabo me rendendo e rodando o\n    clássico\n    "),de=p(T,"CODE",{});var j=l(de);ce=v(j,"npm install redux react-redux --save"),j.forEach(c),ue=v(T,". Eu até compartilhei\n    algumas das ferramentas que eu uso com redux na nossa outra lib\n    "),pe=p(T,"A",{href:!0});var z=l(pe);le=p(z,"CODE",{});var A=l(le);ve=v(A,"react-redux-api-tools"),A.forEach(c),z.forEach(c),fe=v(T,"."),T.forEach(c),ge=u(t),he=p(t,"P",{});var oe=l(he);qe=v(oe,"Não ache que eu odeio o redux; pelo contrário, eu amo. Ele cumpre sua\n    função, é ultra flexível, com poucos efeitos colaterais. Mas vamos ser\n    sinceros: o desconforto quando lemos\n    "),be=p(oe,"CODE",{});var wo=l(be);Ee=v(wo,"mapStateToProps"),wo.forEach(c),xe=v(oe,"\n    pela primeira vez é\n    "),$e=p(oe,"STRONG",{});var ko=l($e);Pe=v(ko,"real"),ko.forEach(c),Ce=v(oe,". Demorei um bom tempo pra entender o que tava\n    acontecendo de verdade. E ainda tem actions, action creators, reducers,\n    dispatches e middlewares, e sagas, e async dispatches; o aprendizado nunca\n    acaba."),oe.forEach(c),Te=u(t),je=p(t,"P",{});var Ro=l(je);ze=v(Ro,"Depois dos primeiros confusos meses, lidar com o redux fica mais fácil (como\n    quase tudo na vida), mas muito,\n    "),Le=p(Ro,"STRONG",{});var yo=l(Le);Me=v(yo,"muito"),yo.forEach(c),Se=v(Ro,"\n    mais verboso. Eu sempre pensei que o redux parecia uma biblioteca muito\n    baixo nível e que eu sempre sou obrigado a especificar, passo a passo,\n    exatamente e estritamente o que precisa ser feito. Zero abstração. E muita\n    cópia e cola."),Ro.forEach(c),De=u(t),Ne=p(t,"P",{});var Fo=l(Ne);Oe=v(Fo,"Cheguei à conclusão de que seria ótimo ter todas as features que gosto na\n    minha configuração do redux - um fluxo para HTTP bem definido, menos\n    repetição, conexão semântica entre actions e reducers -, sem sacrificar\n    nada. Daí me deram a luz verde pra desenvolver internamente uma solução pra\n    isso:\n    "),He=p(Fo,"CODE",{});var Go=l(He);Ie=v(Go,"rel-events"),Go.forEach(c),Ae=v(Fo,"."),Fo.forEach(c),we=u(t),ke=p(t,"H2",{});var Uo=l(ke);Re=v(Uo,"Legal, mas o que raios é "),ye=p(Uo,"CODE",{});var Vo=l(ye);Fe=v(Vo,"rel-events"),Vo.forEach(c),Ge=v(Uo,"?"),Uo.forEach(c),Ue=u(t),Ve=p(t,"P",{});var Zo=l(Ve);Ze=p(Zo,"CODE",{});var Jo=l(Ze);Je=v(Jo,"rel-events"),Jo.forEach(c),Ke=v(Zo,"\n    é uma biblioteca de eventos para react (React Events Library, por isso rel\n    ;]). Ela leva o conceito de eventos, que já existe no redux, pra um nível\n    mais alto de abstração. É uma camada fina por cima do redux que permite que\n    você pare de pensar em actions, reducers, stores e middlewares, pra que você\n    possa focar no que precisa ser feito, que é executar lógica de negócio de\n    forma reativa quando eventos acontecem."),Zo.forEach(c),Be=u(t),Qe=p(t,"P",{});var Ko=l(Qe);We=v(Ko,"Pra isso, vou propor que a gente imagine um cenário bem comum: precisamos\n    fazer com que um usuário faça login na nossa aplicação."),Ko.forEach(c),Xe=u(t),Ye=p(t,"P",{});var Bo=l(Ye);_e=v(Bo,"Nós poderíamos fazer todo o fluxo de requisições dentro dos próprios\n    componentes, mas\n    "),ea=p(Bo,"A",{href:!0});var Qo=l(ea);aa=v(Qo,"como\n      dissemos no nosso outro post"),Qo.forEach(c),oa=v(Bo,", nós não exatamente recomendamos esse\n    caminho - sempre termina com código macarronado. Nós poderíamos usar redux,\n    mas aí nossos devs juniors precisariam antes passar pela barreira do\n    "),sa=p(Bo,"CODE",{});var Wo=l(sa);ra=v(Wo,"mapStateToProps"),Wo.forEach(c),na=v(Bo,", e às vezes nós não temos tempo de falar sobre\n    absolutamente tudo de redux antes de entregar nossos projetos. Nós\n    poderíamos usar sagas, mas aí o redux volta pra nos atazanar em dobro."),Bo.forEach(c),ta=u(t),ia=p(t,"P",{});var Xo=l(ia);ma=v(Xo,"Então, vamos por uns minutos esquecer de actions e reducers e imaginemos um\n    objeto chamado LoginEvent. Sempre que executamos algo sobre esse objeto\n    passando email e senha, coisas acontecem e os dados corretos (de sucesso ou\n    falha do login) são passados pros componentes. Imagine que você não precise\n    saber nada sobre esse objeto, apenas seu nome. Sem reducers, sem actions,\n    sem\n    "),da=p(Xo,"CODE",{});var Yo=l(da);ca=v(Yo,"connect"),Yo.forEach(c),ua=v(Xo,"\n    ou\n    "),pa=p(Xo,"CODE",{});var _o=l(pa);la=v(_o,"mapStateToProps"),_o.forEach(c),va=v(Xo,". Seria algo mais ou menos assim:"),Xo.forEach(c),fa=u(t),d(ga.$$.fragment,t),ha=u(t),qa=p(t,"P",{});var es=l(qa);ba=v(es,"Legal, mas onde colocaríamos todo seu comportamento? Onde tá o código que\n    faz a requisição? Como lidar com casos de erro? Digamos que, além do objeto\n    de evento, nós tenhamos algo que gerencia todo o fluxo do evento, que\n    chamaríamos de Event Manager:"),es.forEach(c),Ea=u(t),d(xa.$$.fragment,t),$a=u(t),Pa=p(t,"P",{});var as=l(Pa);Ca=v(as,"Melhor. Mas como esse manager tá implementado? Porque, se a gente precisa\n    lidar com o fluxo inteiro dentro dele, ele precisa saber de muita coisa:\n    como fazer a requisição, por exemplo, ou o que fazer com o estado global\n    quando a requisição tiver sucesso ou falha. Ah, e seria bom ter um estado\n    intermediário quando a requisição começa, porque a gente ama spinners de\n    loading! Eita, esqueci que eu preciso de um estado inicial pra esse evento\n    também, pra gente ter dados antes mesmo da requisição. Calma, calma, vamo\n    lá:"),as.forEach(c),Ta=u(t),d(ja.$$.fragment,t),za=u(t),La=p(t,"P",{});var os=l(La);Ma=v(os,"É mais ou menos isso que a gente precisa, né? Mas então, como que a gente\n    faria pra registrar quais Componentes que poderiam disparar esse Evento?\n    Como que o Componente pegaria os dados desse evento? Tamo quase lá:"),os.forEach(c),Sa=u(t),d(Da.$$.fragment,t),Na=u(t),Oa=p(t,"P",{});var ss=l(Oa);Ha=v(ss,"E essa é exatamente a API atual para um Evento HTTP (HTTPEvent) da lib\n    "),Ia=p(ss,"CODE",{});var rs=l(Ia);Aa=v(rs,"rel-events"),rs.forEach(c),wa=v(ss,". Nada de actions nem reducers, nada de acoplar as\n    camadas de domínio com a de componentes, nada. Claro, a gente precisaria\n    antes configurar como nossa lib se encaixa com o redux, mas geralmente é uma\n    configuração de uma vez só, e muito bem documentada\n    "),ka=p(ss,"A",{href:!0});var ns=l(ka);Ra=v(ns,"na nossa\n      documentação (ainda só em inglês, com português em breve"),ns.forEach(c),ya=v(ss,")."),ss.forEach(c),Fa=u(t),Ga=p(t,"H2",{});var ts=l(Ga);Ua=v(ts,"Isso parece... bom! Mas e as funcionalidades? Eu quero features!"),ts.forEach(c),Va=u(t),Za=p(t,"P",{});var is=l(Za);Ja=v(is,"Na nossa atual versão beta (0.1.3, de Setembro de 2019), você pode:"),is.forEach(c),Ka=u(t),Ba=p(t,"UL",{});var ms=l(Ba);Qa=p(ms,"LI",{});var ds=l(Qa);Wa=v(ds,"usar um Evento (Event) básico (pras horas em que você não precisa fazer\n      requisições);"),ds.forEach(c),Xa=u(ms),Ya=p(ms,"LI",{});var cs=l(Ya);_a=v(cs,"encadear um Event/HTTPEvent em outro (útil pra quando você quer buscar\n      mais dados depois que um evento teve sucesso);"),cs.forEach(c),eo=u(ms),ao=p(ms,"LI",{});var us=l(ao);oo=v(us,"ter múltiplos Events registrados para um mesmo Componente (porque você\n      provavelmente vai ter um Componente que precisa ler dados de vários\n      lugares);"),us.forEach(c),so=u(ms),ro=p(ms,"LI",{});var ps=l(ro);no=v(ps,"executar código depois das mudanças de estado de um Evento que foi\n      disparado (usando\n      "),to=p(ps,"CODE",{});var ls=l(to);io=v(ls,"afterDispatch"),ls.forEach(c),mo=v(ps,");"),ps.forEach(c),co=u(ms),uo=p(ms,"LI",{});var vs=l(uo);po=v(vs,"executar código depois das mudanças de estado de uma requisição que teve\n      sucesso (usando\n      "),lo=p(vs,"CODE",{});var fs=l(lo);vo=v(fs,"afterSuccess"),fs.forEach(c),fo=v(vs,");"),vs.forEach(c),go=u(ms),ho=p(ms,"LI",{});var gs=l(ho);qo=v(gs,"executar código depois das mudanças de estado de uma requisição que falhou\n      (usando\n      "),bo=p(gs,"CODE",{});var hs=l(bo);Eo=v(hs,"afterFailure"),hs.forEach(c),xo=v(gs,");"),gs.forEach(c),$o=u(ms),Po=p(ms,"LI",{});var qs=l(Po);Co=v(qs,"avaliar se um evento deve ser disparado ou não (com o método\n      "),To=p(qs,"CODE",{});var bs=l(To);jo=v(bs,"shouldDispatch"),bs.forEach(c),zo=v(qs,"\n      do EventManager)."),qs.forEach(c),ms.forEach(c),Lo=u(t),Mo=p(t,"P",{});var Es=l(Mo);So=v(Es,"E muito mais! Tudo isso sem a carga cognitiva, sem as constantes aleatórias,\n    sem os nomes de store manuais e toda a má experiência de desenvolvimento do\n    redux. E a melhor parte: sem uma grande curva de aprendizado. Esse post tem\n    basicamente tudo que você precisa saber pra usar nossa biblioteca no\n    dia-a-dia. Mesmo. Eu sei, porque tô usando!"),Es.forEach(c),Do=u(t),No=p(t,"P",{});var xs=l(No);Oo=v(xs,"Então se você gostou,\n    "),Ho=p(xs,"A",{href:!0});var $s=l(Ho);Io=v($s,"dá uma olhada no nosso\n      repositório no github"),$s.forEach(c),Ao=v(xs,"\n    pra começar a usar e comparilhe o amor! Valeu pela atenção, e eu vejo vocês\n    na próxima!"),xs.forEach(c),t.forEach(c),this.h()},h(){I.src!==(A=z)&&f(I,"src",A),f(I,"alt","Ilustração com as logos do React e do Redux"),f(F,"href","/en/keeping-global-state-management-sane-with-rel-events/"),f(J,"href","https://github.com/labcodes/rel-events"),ae.src!==(oe="https://imgs.xkcd.com/comics/standards.png")&&f(ae,"src","https://imgs.xkcd.com/comics/standards.png"),f(ae,"alt","Tirinha do xkcd que diz que toda vez que reclamamos que temos muitos jeitos de fazer algo, acabamos criando mais um"),f(ee,"href","https://xkcd.com/927/"),f(pe,"href","https://github.com/labcodes/react-redux-api-tools/"),f(ea,"href","https://labcodes.com.br/blog/pt/mantendo-o-estado-global-de-uma-maneira-sa-com-rel-events.html"),f(ka,"href","https://github.com/labcodes/rel-events/tree/master/docs"),f(Ho,"href","https://github.com/labcodes/rel-events")},m(s,r){g(a,document.head,null),h(s,o,r),h(s,$,r),q($,L),q(L,M),h(s,S,r),g(D,s,r),h(s,N,r),h(s,O,r),q(O,H),q(H,I),q(O,w),q(O,k),q(k,R),q(R,y),q(R,F),q(F,G),q(O,U),q(O,V),q(V,Z),q(V,J),q(J,K),q(V,B),q(O,Q),q(O,W),q(W,X),q(O,Y),q(O,_),q(_,ee),q(ee,ae),q(O,se),q(O,re),q(re,ne),q(O,te),q(O,ie),q(ie,me),q(ie,de),q(de,ce),q(ie,ue),q(ie,pe),q(pe,le),q(le,ve),q(ie,fe),q(O,ge),q(O,he),q(he,qe),q(he,be),q(be,Ee),q(he,xe),q(he,$e),q($e,Pe),q(he,Ce),q(O,Te),q(O,je),q(je,ze),q(je,Le),q(Le,Me),q(je,Se),q(O,De),q(O,Ne),q(Ne,Oe),q(Ne,He),q(He,Ie),q(Ne,Ae),q(O,we),q(O,ke),q(ke,Re),q(ke,ye),q(ye,Fe),q(ke,Ge),q(O,Ue),q(O,Ve),q(Ve,Ze),q(Ze,Je),q(Ve,Ke),q(O,Be),q(O,Qe),q(Qe,We),q(O,Xe),q(O,Ye),q(Ye,_e),q(Ye,ea),q(ea,aa),q(Ye,oa),q(Ye,sa),q(sa,ra),q(Ye,na),q(O,ta),q(O,ia),q(ia,ma),q(ia,da),q(da,ca),q(ia,ua),q(ia,pa),q(pa,la),q(ia,va),q(O,fa),g(ga,O,null),q(O,ha),q(O,qa),q(qa,ba),q(O,Ea),g(xa,O,null),q(O,$a),q(O,Pa),q(Pa,Ca),q(O,Ta),g(ja,O,null),q(O,za),q(O,La),q(La,Ma),q(O,Sa),g(Da,O,null),q(O,Na),q(O,Oa),q(Oa,Ha),q(Oa,Ia),q(Ia,Aa),q(Oa,wa),q(Oa,ka),q(ka,Ra),q(Oa,ya),q(O,Fa),q(O,Ga),q(Ga,Ua),q(O,Va),q(O,Za),q(Za,Ja),q(O,Ka),q(O,Ba),q(Ba,Qa),q(Qa,Wa),q(Ba,Xa),q(Ba,Ya),q(Ya,_a),q(Ba,eo),q(Ba,ao),q(ao,oo),q(Ba,so),q(Ba,ro),q(ro,no),q(ro,to),q(to,io),q(ro,mo),q(Ba,co),q(Ba,uo),q(uo,po),q(uo,lo),q(lo,vo),q(uo,fo),q(Ba,go),q(Ba,ho),q(ho,qo),q(ho,bo),q(bo,Eo),q(ho,xo),q(Ba,$o),q(Ba,Po),q(Po,Co),q(Po,To),q(To,jo),q(Po,zo),q(O,Lo),q(O,Mo),q(Mo,So),q(O,Do),q(O,No),q(No,Oo),q(No,Ho),q(Ho,Io),q(No,Ao),e[2](O),wo=!0},p(e,[a]){const o={};2&a&&(o.text=e[1]),D.$set(o)},i(e){wo||(b(a.$$.fragment,e),b(D.$$.fragment,e),b(ga.$$.fragment,e),b(xa.$$.fragment,e),b(ja.$$.fragment,e),b(Da.$$.fragment,e),wo=!0)},o(e){E(a.$$.fragment,e),E(D.$$.fragment,e),E(ga.$$.fragment,e),E(xa.$$.fragment,e),E(ja.$$.fragment,e),E(Da.$$.fragment,e),wo=!1},d(s){x(a),s&&c(o),s&&c($),s&&c(S),x(D,s),s&&c(N),s&&c(O),x(ga),x(xa),x(ja),x(Da),e[2](null)}}}function M(e,a,o){let s,r;return e.$$.update=()=>{1&e.$$.dirty&&o(1,r=s&&s.textContent)},[s,r,function(e){$[e?"unshift":"push"]((()=>{s=e,o(0,s)}))}]}export default class extends e{constructor(e){super(),a(this,e,M,L,o,{})}}
