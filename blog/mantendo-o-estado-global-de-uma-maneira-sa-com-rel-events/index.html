<!doctype html> <html lang=en> <head> <meta charset=utf-8> <meta content="width=device-width,initial-scale=1" name=viewport> <meta content=#333333 name=theme-color> <base href=/ > <link href=manifest.json rel=manifest crossorigin=use-credentials> <link href=favicon.png rel=icon type=image/png> <script>__SAPPER__={baseUrl:"",preloaded:[void 0,{},{}]};if('serviceWorker' in navigator)navigator.serviceWorker.register('/service-worker.js');(function(){try{eval("async function x(){}");var main="/client/client.ba4c128a.js"}catch(e){main="/client/legacy/client.b5ae4b81.js"};var s=document.createElement("script");try{new Function("if(0)import('')")();s.src=main;s.type="module";s.crossOrigin="use-credentials";}catch(e){s.src="/client/shimport@2.0.4.js";s.setAttribute("data-main",main);}document.head.appendChild(s);}());</script> <link href=client/client-2e2ca2b4.css rel=stylesheet> <title> Mantendo o estado global de uma maneira sã com rel-events - luciano@ratamero.com </title><style>.hljs{display:block;overflow-x:auto;padding:.5em;background:#1e1e1e;color:#dcdcdc}.hljs-keyword,.hljs-literal,.hljs-name,.hljs-symbol{color:#569cd6}.hljs-link{color:#569cd6;text-decoration:underline}.hljs-built_in,.hljs-type{color:#4ec9b0}.hljs-class,.hljs-number{color:#b8d7a3}.hljs-meta-string,.hljs-string{color:#d69d85}.hljs-regexp,.hljs-template-tag{color:#9a5334}.hljs-formula,.hljs-function,.hljs-params,.hljs-subst,.hljs-title{color:#dcdcdc}.hljs-comment,.hljs-quote{color:#57a64a;font-style:italic}.hljs-doctag{color:#608b4e}.hljs-meta,.hljs-meta-keyword,.hljs-tag{color:#9b9b9b}.hljs-template-variable,.hljs-variable{color:#bd63c5}.hljs-attr,.hljs-attribute,.hljs-builtin-name{color:#9cdcfe}.hljs-section{color:gold}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-bullet,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-id,.hljs-selector-pseudo,.hljs-selector-tag{color:#d7ba7d}.hljs-addition{background-color:#144212;display:inline-block;width:100%}.hljs-deletion{background-color:#600;display:inline-block;width:100%}</style><link href=https://fonts.gstatic.com rel=preconnect data-svelte=svelte-1vo6mso><link href="https://fonts.googleapis.com/css2?family=Poppins:ital,wght@0,400;0,500;0,700;1,400&display=swap" rel=stylesheet data-svelte=svelte-1vo6mso><link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono&display=swap" rel=stylesheet data-svelte=svelte-1vo6mso><meta content="Nesse post, discutiremos como usar a rel-events para lidar com o estado global de sua app React de uma maneira mais fácil e sã :]" name=description data-svelte=svelte-nu5ue2><meta content="Luciano Ratamero, rel-events, react, redux, grandes projetos, arquitetura, planejamento, frontend, javascript, frameworks" name=keywords data-svelte=svelte-nu5ue2> <link href=/client/client.ba4c128a.js rel=modulepreload as=script crossorigin=use-credentials><link href=/client/client-2e2ca2b4.css rel=preload as=style><link href=/client/index.942d67cd.js rel=modulepreload as=script crossorigin=use-credentials><link href=/client/4-registering-component.61f1b1f9.js rel=modulepreload as=script crossorigin=use-credentials><link href=/client/inject_styles.5607aec6.js.gz rel=modulepreload as=script crossorigin=use-credentials></head> <body> <div id=sapper> <section class="dark-theme theme"><section class=transition-wrapper><main><article class=blog-post> <h1><mark>Mantendo o estado global de uma maneira sã com rel-events</mark></h1> <p class=meta>2019-09-19</p> <figure><img alt="Ilustração com as logos do React e do Redux" src=/client/71a9ff9732f6eb60.png></figure> <p><em>for native english speakers, <a href=/en/keeping-global-state-management-sane-with-rel-events/ >here's the translated post</a></em></p> <p>Manter uma aplicação react grande e complexa não é um trabalho pra amadores. Não importa o que você escolher para lidar com a máquina de estados da aplicação, é quase certo de que é algo difícil de aprender, como redux, ou realmente complicado, como fazer uma camada de serviços na mão. Com o objetivo de fazer com que novas pessoas possam entrar fácil nos projetos, a galera da Labcodes decidiu que tava na hora de dar mais atenção e uma verdadeira solução pra esse tipo de problema. Nossa resposta foi criar a biblioteca <a href=https://github.com/labcodes/rel-events>rel-events</a>. </p> <h2>Pra que mais uma biblioteca para gerenciar estado?</h2> <p><a href=https://xkcd.com/927/ ><img alt="xkcd tá sempre certo" src=https://imgs.xkcd.com/comics/standards.png></a></p> <p>Sempre que eu penso em criar uma biblioteca nova, essa tirinha do xkcd vem me assombrar. Acreditem, eu não quero ser o tipo de pessoa que faz tudo por conta própria em vez de contribuir com algo que já existe, e esse é um dos problemas com essa mentalidade de forkar tudo. No entanto, eu sempre quis resolver um problema com o qual eu lido diariamente: usar uma biblioteca qualquer pra separar lógica de negócio/domínio dos meus componentes react. </p> <p>Mas no fim do dia, depois de pensar muito, acabo me rendendo e rodando o clássico <code>npm install redux react-redux --save</code>. Eu até compartilhei algumas das ferramentas que eu uso com redux na nossa outra lib <a href=https://github.com/labcodes/react-redux-api-tools/ ><code>react-redux-api-tools</code></a>. </p> <p>Não ache que eu odeio o redux; pelo contrário, eu amo. Ele cumpre sua função, é ultra flexível, com poucos efeitos colaterais. Mas vamos ser sinceros: o desconforto quando lemos <code>mapStateToProps</code> pela primeira vez é <strong>real</strong>. Demorei um bom tempo pra entender o que tava acontecendo de verdade. E ainda tem actions, action creators, reducers, dispatches e middlewares, e sagas, e async dispatches; o aprendizado nunca acaba. </p> <p>Depois dos primeiros confusos meses, lidar com o redux fica mais fácil (como quase tudo na vida), mas muito, <strong>muito</strong> mais verboso. Eu sempre pensei que o redux parecia uma biblioteca muito baixo nível e que eu sempre sou obrigado a especificar, passo a passo, exatamente e estritamente o que precisa ser feito. Zero abstração. E muita cópia e cola. </p> <p>Cheguei à conclusão de que seria ótimo ter todas as features que gosto na minha configuração do redux - um fluxo para HTTP bem definido, menos repetição, conexão semântica entre actions e reducers -, sem sacrificar nada. Daí me deram a luz verde pra desenvolver internamente uma solução pra isso: <code>rel-events</code>. </p> <h2>Legal, mas o que raios é <code>rel-events</code>?</h2> <p><code>rel-events</code> é uma biblioteca de eventos para react (React Events Library, por isso rel ;]). Ela leva o conceito de eventos, que já existe no redux, pra um nível mais alto de abstração. É uma camada fina por cima do redux que permite que você pare de pensar em actions, reducers, stores e middlewares, pra que você possa focar no que precisa ser feito, que é executar lógica de negócio de forma reativa quando eventos acontecem. </p> <p>Pra isso, vou propor que a gente imagine um cenário bem comum: precisamos fazer com que um usuário faça login na nossa aplicação. </p> <p>Nós poderíamos fazer todo o fluxo de requisições dentro dos próprios componentes, mas <a href=https://labcodes.com.br/blog/pt/mantendo-o-estado-global-de-uma-maneira-sa-com-rel-events.html>como dissemos no nosso outro post</a>, nós não exatamente recomendamos esse caminho - sempre termina com código macarronado. Nós poderíamos usar redux, mas aí nossos devs juniors precisariam antes passar pela barreira do <code>mapStateToProps</code>, e às vezes nós não temos tempo de falar sobre absolutamente tudo de redux antes de entregar nossos projetos. Nós poderíamos usar sagas, mas aí o redux volta pra nos atazanar em dobro. </p> <p>Então, vamos por uns minutos esquecer de actions e reducers e imaginemos um objeto chamado LoginEvent. Sempre que executamos algo sobre esse objeto passando email e senha, coisas acontecem e os dados corretos (de sucesso ou falha do login) são passados pros componentes. Imagine que você não precise saber nada sobre esse objeto, apenas seu nome. Sem reducers, sem actions, sem <code>connect</code> ou <code>mapStateToProps</code>. Seria algo mais ou menos assim: </p> <figure><img alt="Evento Imaginário" src=/client/19b35ae3df403d25.png></figure> <p>Legal, mas onde colocaríamos todo seu comportamento? Onde tá o código que faz a requisição? Como lidar com casos de erro? Digamos que, além do objeto de evento, nós tenhamos algo que gerencia todo o fluxo do evento, que chamaríamos de Event Manager: </p> <figure><img alt="Basic rel-events HTTPEvent" src=/client/c7661dd4800c4137.png></figure> <p>Melhor. Mas como esse manager tá implementado? Porque, se a gente precisa lidar com o fluxo inteiro dentro dele, ele precisa saber de muita coisa: como fazer a requisição, por exemplo, ou o que fazer com o estado global quando a requisição tiver sucesso ou falha. Ah, e seria bom ter um estado intermediário quando a requisição começa, porque a gente ama spinners de loading! Eita, esqueci que eu preciso de um estado inicial pra esse evento também, pra gente ter dados antes mesmo da requisição. Calma, calma, vamo lá: </p> <figure><img alt=LoginEventManager src=/client/867b1ba4ec27bfe7.png></figure> <p>É mais ou menos isso que a gente precisa, né? Mas então, como que a gente faria pra registrar quais Componentes que poderiam disparar esse Evento? Como que o Componente pegaria os dados desse evento? Tamo quase lá: </p> <figure><img alt="Registering the component" src=/client/1958bf4dfde24086.png></figure> <p>E essa é exatamente a API atual para um Evento HTTP (HTTPEvent) da lib <code>rel-events</code>. Nada de actions nem reducers, nada de acoplar as camadas de domínio com a de componentes, nada. Claro, a gente precisaria antes configurar como nossa lib se encaixa com o redux, mas geralmente é uma configuração de uma vez só, e muito bem documentada <a href=https://github.com/labcodes/rel-events/tree/master/docs>na nossa documentação (ainda só em inglês, com português em breve</a>). </p> <h2>Isso parece... bom! Mas e as funcionalidades? Eu quero features!</h2> <p>Na nossa atual versão beta (0.1.3, de Setembro de 2019), você pode:</p> <ul><li>usar um Evento (Event) básico (pras horas em que você não precisa fazer requisições); </li> <li>encadear um Event/HTTPEvent em outro (útil pra quando você quer buscar mais dados depois que um evento teve sucesso); </li> <li>ter múltiplos Events registrados para um mesmo Componente (porque você provavelmente vai ter um Componente que precisa ler dados de vários lugares); </li> <li>executar código depois das mudanças de estado de um Evento que foi disparado (usando <code>afterDispatch</code>); </li> <li>executar código depois das mudanças de estado de uma requisição que teve sucesso (usando <code>afterSuccess</code>); </li> <li>executar código depois das mudanças de estado de uma requisição que falhou (usando <code>afterFailure</code>); </li> <li>avaliar se um evento deve ser disparado ou não (com o método <code>shouldDispatch</code> do EventManager). </ul> <p>E muito mais! Tudo isso sem a carga cognitiva, sem as constantes aleatórias, sem os nomes de store manuais e toda a má experiência de desenvolvimento do redux. E a melhor parte: sem uma grande curva de aprendizado. Esse post tem basicamente tudo que você precisa saber pra usar nossa biblioteca no dia-a-dia. Mesmo. Eu sei, porque tô usando! </p> <p>Então se você gostou, <a href=https://github.com/labcodes/rel-events>dá uma olhada no nosso repositório no github</a> pra começar a usar e comparilhe o amor! Valeu pela atenção, e eu vejo vocês na próxima! </article></main></section> <nav class=svelte-12rvnlo><ul class=svelte-12rvnlo><li class=svelte-12rvnlo><a href=/ class=svelte-12rvnlo rel=prefetch>about</a></li> <li class=svelte-12rvnlo><a href=blog class=svelte-12rvnlo rel=prefetch aria-current=page>blog</a></li> <li class=svelte-12rvnlo><a href=previous-talks class=svelte-12rvnlo rel=prefetch>talks</a></ul> </nav></section></div> 