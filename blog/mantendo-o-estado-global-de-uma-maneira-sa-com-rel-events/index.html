<!doctype html> <html lang=en> <head> <meta charset=utf-8> <meta content="width=device-width,initial-scale=1" name=viewport> <meta content=#333333 name=theme-color> <base href=/ > <link href=manifest.json rel=manifest crossorigin=use-credentials> <link href=favicon.png rel=icon type=image/png> <script>__SAPPER__={baseUrl:"",preloaded:[void 0,{},{}]};if('serviceWorker' in navigator)navigator.serviceWorker.register('/service-worker.js');(function(){try{eval("async function x(){}");var main="/client/client.311a5b93.js"}catch(e){main="/client/legacy/client.eda691f8.js"};var s=document.createElement("script");try{new Function("if(0)import('')")();s.src=main;s.type="module";s.crossOrigin="use-credentials";}catch(e){s.src="/client/shimport@2.0.4.js";s.setAttribute("data-main",main);}document.head.appendChild(s);}());</script> <link href=client/client-a688d852.css rel=stylesheet><link href=client/Icon-dfea4060.css rel=stylesheet> <style>.hljs-comment,.hljs-quote{color:#969896}.hljs-deletion,.hljs-name,.hljs-regexp,.hljs-selector-class,.hljs-selector-id,.hljs-tag,.hljs-template-variable,.hljs-variable{color:#d54e53}.hljs-built_in,.hljs-builtin-name,.hljs-link,.hljs-literal,.hljs-meta,.hljs-number,.hljs-params,.hljs-type{color:#e78c45}.hljs-attribute{color:#e7c547}.hljs-addition,.hljs-bullet,.hljs-string,.hljs-symbol{color:#b9ca4a}.hljs-section,.hljs-title{color:#7aa6da}.hljs-keyword,.hljs-selector-tag{color:#c397d8}.hljs{display:block;overflow-x:auto;background:#000;color:#eaeaea;padding:.5em}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><title>Mantendo o estado global de uma maneira sã com rel-events - luciano@ratamero.com</title> <meta content="Nesse post, discutiremos como usar a rel-events para lidar com o estado global de sua app React de uma maneira mais fácil e sã :]" name=description> <meta content="Luciano Ratamero, rel-events, react, redux, grandes projetos, arquitetura, planejamento, frontend, javascript, frameworks" name=keywords> <meta content="Mantendo o estado global de uma maneira sã com rel-events - luciano@ratamero.com" property=og:title> <meta content="Nesse post, discutiremos como usar a rel-events para lidar com o estado global de sua app React de uma maneira mais fácil e sã :]" property=og:description> <meta content=https://www.ratamero.com/default-media-share.jpg property=og:image> <meta content=https://www.ratamero.com property=og:url> <meta content="Mantendo o estado global de uma maneira sã com rel-events - luciano@ratamero.com" name=twitter:title> <meta content="Nesse post, discutiremos como usar a rel-events para lidar com o estado global de sua app React de uma maneira mais fácil e sã :]" name=twitter:description> <meta content=https://www.ratamero.com/default-media-share.jpg name=twitter:image> <meta content=summary_large_image name=twitter:card> <link href=https://fonts.gstatic.com rel=preconnect> <link href="https://fonts.googleapis.com/css2?family=Source+Sans+Pro:ital,wght@0,400;0,700;1,400&display=swap" rel=stylesheet> <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono&display=swap" rel=stylesheet> <link href=/client/client.311a5b93.js rel=modulepreload as=script crossorigin=use-credentials><link href=/client/client-a688d852.css rel=preload as=style><link href=/client/index.18f48511.js rel=modulepreload as=script crossorigin=use-credentials><link href=/client/Icon.06acf308.js rel=modulepreload as=script crossorigin=use-credentials><link href=/client/MetaTags.39c5eacd.js rel=modulepreload as=script crossorigin=use-credentials><link href=/client/index.ec9d7c60.js rel=modulepreload as=script crossorigin=use-credentials><link href=/client/cover.4038dd1b.js rel=modulepreload as=script crossorigin=use-credentials><link href=/client/inject_styles.5607aec6.js.gz rel=modulepreload as=script crossorigin=use-credentials><link href=/client/Icon-dfea4060.css rel=preload as=style></head> <body> <div id=sapper> <section class="light-theme theme"><section class="loading-overlay svelte-1rtsid8"><div class="circle svelte-gkf9c4" style=--size:60px;--colorInner:#676778;--colorCenter:#40B3FF;--colorOuter:#FF3E00></div></section> <section class=transition-wrapper><main><article class=blog-post> <h1><mark>Mantendo o estado global de uma maneira sã com rel-events</mark></h1> <p class=meta>2019-09-19 </p> <article><figure><img alt="Ilustração com as logos do React e do Redux" src=/client/71a9ff9732f6eb60.png></figure> <p><em>for native english speakers, <a href=/en/keeping-global-state-management-sane-with-rel-events/ >here's the translated post</a></em></p> <p>Manter uma aplicação react grande e complexa não é um trabalho pra amadores. Não importa o que você escolher para lidar com a máquina de estados da aplicação, é quase certo de que é algo difícil de aprender, como redux, ou realmente complicado, como fazer uma camada de serviços na mão. Com o objetivo de fazer com que novas pessoas possam entrar fácil nos projetos, a galera da Labcodes decidiu que tava na hora de dar mais atenção e uma verdadeira solução pra esse tipo de problema. Nossa resposta foi criar a biblioteca <a href=https://github.com/labcodes/rel-events>rel-events</a>. </p> <h2>Pra que mais uma biblioteca para gerenciar estado?</h2> <p><a href=https://xkcd.com/927/ ><img alt="Tirinha do xkcd que diz que toda vez que reclamamos que temos muitos jeitos de fazer algo, acabamos criando mais um" src=https://imgs.xkcd.com/comics/standards.png></a></p> <p>Sempre que eu penso em criar uma biblioteca nova, essa tirinha do xkcd vem me assombrar. Acreditem, eu não quero ser o tipo de pessoa que faz tudo por conta própria em vez de contribuir com algo que já existe, e esse é um dos problemas com essa mentalidade de forkar tudo. No entanto, eu sempre quis resolver um problema com o qual eu lido diariamente: usar uma biblioteca qualquer pra separar lógica de negócio/domínio dos meus componentes react. </p> <p>Mas no fim do dia, depois de pensar muito, acabo me rendendo e rodando o clássico <code>npm install redux react-redux --save</code>. Eu até compartilhei algumas das ferramentas que eu uso com redux na nossa outra lib <a href=https://github.com/labcodes/react-redux-api-tools/ ><code>react-redux-api-tools</code></a>. </p> <p>Não ache que eu odeio o redux; pelo contrário, eu amo. Ele cumpre sua função, é ultra flexível, com poucos efeitos colaterais. Mas vamos ser sinceros: o desconforto quando lemos <code>mapStateToProps</code> pela primeira vez é <strong>real</strong>. Demorei um bom tempo pra entender o que tava acontecendo de verdade. E ainda tem actions, action creators, reducers, dispatches e middlewares, e sagas, e async dispatches; o aprendizado nunca acaba. </p> <p>Depois dos primeiros confusos meses, lidar com o redux fica mais fácil (como quase tudo na vida), mas muito, <strong>muito</strong> mais verboso. Eu sempre pensei que o redux parecia uma biblioteca muito baixo nível e que eu sempre sou obrigado a especificar, passo a passo, exatamente e estritamente o que precisa ser feito. Zero abstração. E muita cópia e cola. </p> <p>Cheguei à conclusão de que seria ótimo ter todas as features que gosto na minha configuração do redux - um fluxo para HTTP bem definido, menos repetição, conexão semântica entre actions e reducers -, sem sacrificar nada. Daí me deram a luz verde pra desenvolver internamente uma solução pra isso: <code>rel-events</code>. </p> <h2>Legal, mas o que raios é <code>rel-events</code>?</h2> <p><code>rel-events</code> é uma biblioteca de eventos para react (React Events Library, por isso rel ;]). Ela leva o conceito de eventos, que já existe no redux, pra um nível mais alto de abstração. É uma camada fina por cima do redux que permite que você pare de pensar em actions, reducers, stores e middlewares, pra que você possa focar no que precisa ser feito, que é executar lógica de negócio de forma reativa quando eventos acontecem. </p> <p>Pra isso, vou propor que a gente imagine um cenário bem comum: precisamos fazer com que um usuário faça login na nossa aplicação. </p> <p>Nós poderíamos fazer todo o fluxo de requisições dentro dos próprios componentes, mas <a href=https://labcodes.com.br/blog/pt/mantendo-o-estado-global-de-uma-maneira-sa-com-rel-events.html>como dissemos no nosso outro post</a>, nós não exatamente recomendamos esse caminho - sempre termina com código macarronado. Nós poderíamos usar redux, mas aí nossos devs juniors precisariam antes passar pela barreira do <code>mapStateToProps</code>, e às vezes nós não temos tempo de falar sobre absolutamente tudo de redux antes de entregar nossos projetos. Nós poderíamos usar sagas, mas aí o redux volta pra nos atazanar em dobro. </p> <p>Então, vamos por uns minutos esquecer de actions e reducers e imaginemos um objeto chamado LoginEvent. Sempre que executamos algo sobre esse objeto passando email e senha, coisas acontecem e os dados corretos (de sucesso ou falha do login) são passados pros componentes. Imagine que você não precise saber nada sobre esse objeto, apenas seu nome. Sem reducers, sem actions, sem <code>connect</code> ou <code>mapStateToProps</code>. Seria algo mais ou menos assim: </p> <pre class=hljs><code><span class=hljs-keyword>import</span> { HTTPEvent } <span class=hljs-keyword>from</span> <span class=hljs-string>"rel-events"</span>;</code><br><code></code><br><code><span class=hljs-keyword>export</span> <span class=hljs-keyword>const</span> LoginEvent = <span class=hljs-keyword>new</span> HTTPEvent({ <span class=hljs-attr>name</span>: <span class=hljs-string>"login"</span> });</code></pre> <p>Legal, mas onde colocaríamos todo seu comportamento? Onde tá o código que faz a requisição? Como lidar com casos de erro? Digamos que, além do objeto de evento, nós tenhamos algo que gerencia todo o fluxo do evento, que chamaríamos de Event Manager: </p> <pre class=hljs><code><span class=hljs-keyword>import</span> { HTTPEvent } <span class=hljs-keyword>from</span> <span class=hljs-string>"rel-events"</span>;</code><br><code><span class=hljs-keyword>import</span> { LoginEventManager } <span class=hljs-keyword>from</span> <span class=hljs-string>"./eventManagers"</span>;</code><br><code></code><br><code><span class=hljs-keyword>export</span> <span class=hljs-keyword>const</span> LoginEvent = <span class=hljs-keyword>new</span> HTTPEvent({</code><br><code>  <span class=hljs-attr>name</span>: <span class=hljs-string>"login"</span>,</code><br><code>  <span class=hljs-attr>manager</span>: <span class=hljs-keyword>new</span> LoginEventManager(),</code><br><code>});</code></pre> <p>Melhor. Mas como esse manager tá implementado? Porque, se a gente precisa lidar com o fluxo inteiro dentro dele, ele precisa saber de muita coisa: como fazer a requisição, por exemplo, ou o que fazer com o estado global quando a requisição tiver sucesso ou falha. Ah, e seria bom ter um estado intermediário quando a requisição começa, porque a gente ama spinners de loading! Eita, esqueci que eu preciso de um estado inicial pra esse evento também, pra gente ter dados antes mesmo da requisição. Calma, calma, vamo lá: </p> <pre class=hljs><code><span class=hljs-keyword>import</span> { fetchFromApi } <span class=hljs-keyword>from</span> <span class=hljs-string>"rel-events"</span>;</code><br><code></code><br><code><span class=hljs-keyword>export</span> <span class=hljs-class><span class=hljs-keyword>class</span> <span class=hljs-title>LoginEventManager</span> </span>{</code><br><code>  initialState = { <span class=hljs-attr>isLoading</span>: <span class=hljs-literal>false</span>, <span class=hljs-attr>username</span>: <span class=hljs-string>"Anonymous"</span> };</code><br><code></code><br><code>  call = <span class=hljs-function>(<span class=hljs-params>user</span>) =></span> {</code><br><code>    <span class=hljs-keyword>return</span> <span class=hljs-function><span class=hljs-params>()</span> =></span> fetchFromApi(</code><br><code>      <span class=hljs-string>"/api/login"</span>,</code><br><code>      { <span class=hljs-attr>method</span>: <span class=hljs-string>"POST"</span>, <span class=hljs-attr>body</span>: <span class=hljs-built_in>JSON</span>.stringify(user) }</code><br><code>    );</code><br><code>  }</code><br><code></code><br><code>  onDispatch = <span class=hljs-function>(<span class=hljs-params>state, event</span>) =></span> ({</code><br><code>    ...state,</code><br><code>    <span class=hljs-attr>isLoading</span>: <span class=hljs-literal>true</span>,</code><br><code>    <span class=hljs-attr>username</span>: <span class=hljs-keyword>this</span>.initialState.username</code><br><code>  })</code><br><code></code><br><code>  onSuccess = <span class=hljs-function>(<span class=hljs-params>state, event</span>) =></span> ({</code><br><code>    ...state,</code><br><code>    <span class=hljs-attr>isLoading</span>: <span class=hljs-keyword>this</span>.initialState.isLoading,</code><br><code>    <span class=hljs-attr>username</span>: event.response.data.username</code><br><code>  })</code><br><code></code><br><code>  onFailure = <span class=hljs-function>(<span class=hljs-params>state, event</span>) =></span> ({</code><br><code>    ...state,</code><br><code>    <span class=hljs-attr>isLoading</span>: <span class=hljs-keyword>this</span>.initialState.isLoading,</code><br><code>    <span class=hljs-attr>username</span>: <span class=hljs-keyword>this</span>.initialState.username,</code><br><code>    <span class=hljs-attr>error</span>: event.error.data</code><br><code>  })</code><br><code>});</code></pre> <p>É mais ou menos isso que a gente precisa, né? Mas então, como que a gente faria pra registrar quais Componentes que poderiam disparar esse Evento? Como que o Componente pegaria os dados desse evento? Tamo quase lá: </p> <pre class=hljs><code><span class=hljs-comment>// LoginComponent.js</span></code><br><code><span class=hljs-keyword>import</span> React <span class=hljs-keyword>from</span> <span class=hljs-string>"react"</span>;</code><br><code><span class=hljs-keyword>import</span> { LoginEvent } <span class=hljs-keyword>from</span> <span class=hljs-string>"./events"</span>;</code><br><code></code><br><code><span class=hljs-keyword>export</span> <span class=hljs-class><span class=hljs-keyword>class</span> <span class=hljs-title>LoginComponent</span> <span class=hljs-keyword>extends</span> <span class=hljs-title>React</span>.<span class=hljs-title>Component</span> </span>{</code><br><code>  handleSubmit = <span class=hljs-function><span class=hljs-params>()</span> =></span> {</code><br><code>    <span class=hljs-keyword>const</span> { user } = <span class=hljs-keyword>this</span>.state;</code><br><code>    <span class=hljs-comment>// o Evento injeta seu gatilho como prop, com o mesmo nome do Evento ("login")</span></code><br><code>    <span class=hljs-keyword>const</span> { login } = <span class=hljs-keyword>this</span>.props;</code><br><code></code><br><code>    login(user);</code><br><code>  }</code><br><code></code><br><code>  render() {</code><br><code>    <span class=hljs-keyword>const</span> { username } = <span class=hljs-keyword>this</span>.props;</code><br><code>    <span class=hljs-keyword>return</span> (</code><br><code>      &lt;React.Fragment></code><br><code>        &lt;h1>Hello, {username}&lt;/h1></code><br><code>        &lt;form>{ /* inputs e botão de submit */ }&lt;/form></code><br><code>      &lt;/React.Fragment></code><br><code>    );</code><br><code>  }</code><br><code>});</code><br><code></code><br><code><span class=hljs-comment>// e aqui, registramos o Componente no Evento,</span></code><br><code><span class=hljs-comment>// que injeta o gatilho como descrito acima</span></code><br><code><span class=hljs-comment>// e também pedimos que o valor de "username" do Evento seja injetado como prop</span></code><br><code><span class=hljs-keyword>export</span> <span class=hljs-keyword>default</span> LoginEvent.register({</code><br><code>  <span class=hljs-attr>Component</span>: LoginComponent,</code><br><code>  <span class=hljs-attr>props</span>: [<span class=hljs-string>"username"</span>]</code><br><code>});</code></pre> <p>E essa é exatamente a API atual para um Evento HTTP (HTTPEvent) da lib <code>rel-events</code>. Nada de actions nem reducers, nada de acoplar as camadas de domínio com a de componentes, nada. Claro, a gente precisaria antes configurar como nossa lib se encaixa com o redux, mas geralmente é uma configuração de uma vez só, e muito bem documentada <a href=https://github.com/labcodes/rel-events/tree/master/docs>na nossa documentação (ainda só em inglês, com português em breve</a>). </p> <h2>Isso parece... bom! Mas e as funcionalidades? Eu quero features!</h2> <p>Na nossa atual versão beta (0.1.3, de Setembro de 2019), você pode:</p> <ul><li>usar um Evento (Event) básico (pras horas em que você não precisa fazer requisições); </li> <li>encadear um Event/HTTPEvent em outro (útil pra quando você quer buscar mais dados depois que um evento teve sucesso); </li> <li>ter múltiplos Events registrados para um mesmo Componente (porque você provavelmente vai ter um Componente que precisa ler dados de vários lugares); </li> <li>executar código depois das mudanças de estado de um Evento que foi disparado (usando <code>afterDispatch</code>); </li> <li>executar código depois das mudanças de estado de uma requisição que teve sucesso (usando <code>afterSuccess</code>); </li> <li>executar código depois das mudanças de estado de uma requisição que falhou (usando <code>afterFailure</code>); </li> <li>avaliar se um evento deve ser disparado ou não (com o método <code>shouldDispatch</code> do EventManager). </ul> <p>E muito mais! Tudo isso sem a carga cognitiva, sem as constantes aleatórias, sem os nomes de store manuais e toda a má experiência de desenvolvimento do redux. E a melhor parte: sem uma grande curva de aprendizado. Esse post tem basicamente tudo que você precisa saber pra usar nossa biblioteca no dia-a-dia. Mesmo. Eu sei, porque tô usando! </p> <p>Então se você gostou, <a href=https://github.com/labcodes/rel-events>dá uma olhada no nosso repositório no github</a> pra começar a usar e comparilhe o amor! Valeu pela atenção, e eu vejo vocês na próxima! </article></article></main></section> <nav class=svelte-1kh6syz><ul class=svelte-1kh6syz><li class=svelte-1kh6syz><a href=/ class=svelte-1kh6syz rel=prefetch>about</a></li> <li class=svelte-1kh6syz><a href=blog/page/1 class=svelte-1kh6syz rel=prefetch aria-current=page>blog</a></li> <li class=svelte-1kh6syz><a href=previous-talks class=svelte-1kh6syz rel=prefetch>talks</a></ul> </nav> </section></div> <script> document.addEventListener('readystatechange', function () {
			if (document.readyState === 'interactive') {
				// set theme
				document.getElementsByClassName('theme')[0].classList = window.matchMedia &&
					window.matchMedia("(prefers-color-scheme: dark)").matches
					? "theme dark-theme"
					: "theme light-theme";

				// fix height on chrome mobile
				let vh = window.innerHeight * 0.01;
				// Then we set the value in the --vh custom property to the root of the document
				document.documentElement.style.setProperty("--vh", `${vh}px`);

				const isChrome = navigator.userAgent.indexOf("Chrome") > -1;
				if (isChrome) {
					document.getElementsByClassName("theme")[0].style["min-height"] =
						"calc(var(--vh, 1vh) * 100)";
				}

				// We listen to the resize event
				window.addEventListener("resize", () => {
					// We execute the same script as before
					let vh = window.innerHeight * 0.01;
					document.documentElement.style.setProperty("--vh", `${vh}px`);

					if (isChrome) {
						document.getElementsByClassName("theme")[0].style["min-height"] =
							"calc(var(--vh, 1vh) * 100)";
					}
				});
			}
		}); </script> 