<!doctype html> <html lang=en> <head> <meta charset=utf-8> <meta content="width=device-width,initial-scale=1" name=viewport> <meta content=#333333 name=theme-color> <base href=/ > <link href=manifest.json rel=manifest crossorigin=use-credentials> <link href=favicon.png rel=icon type=image/png> <script>__SAPPER__={baseUrl:"",preloaded:[void 0,{},{}]};if('serviceWorker' in navigator)navigator.serviceWorker.register('/service-worker.js');(function(){try{eval("async function x(){}");var main="/client/client.311a5b93.js"}catch(e){main="/client/legacy/client.eda691f8.js"};var s=document.createElement("script");try{new Function("if(0)import('')")();s.src=main;s.type="module";s.crossOrigin="use-credentials";}catch(e){s.src="/client/shimport@2.0.4.js";s.setAttribute("data-main",main);}document.head.appendChild(s);}());</script> <link href=client/client-a688d852.css rel=stylesheet><link href=client/Icon-dfea4060.css rel=stylesheet> <style>.hljs-comment,.hljs-quote{color:#969896}.hljs-deletion,.hljs-name,.hljs-regexp,.hljs-selector-class,.hljs-selector-id,.hljs-tag,.hljs-template-variable,.hljs-variable{color:#d54e53}.hljs-built_in,.hljs-builtin-name,.hljs-link,.hljs-literal,.hljs-meta,.hljs-number,.hljs-params,.hljs-type{color:#e78c45}.hljs-attribute{color:#e7c547}.hljs-addition,.hljs-bullet,.hljs-string,.hljs-symbol{color:#b9ca4a}.hljs-section,.hljs-title{color:#7aa6da}.hljs-keyword,.hljs-selector-tag{color:#c397d8}.hljs{display:block;overflow-x:auto;background:#000;color:#eaeaea;padding:.5em}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><title>Desacoplando a lógica de componentes React - luciano@ratamero.com</title> <meta content="Nesse post, discutiremos como separar as lógicas de renderização e de domínio usando React e Redux :]" name=description> <meta content="Luciano Ratamero, react, redux, grandes projetos, arquitetura, planejamento, frontend, javascript, frameworks" name=keywords> <meta content="Desacoplando a lógica de componentes React - luciano@ratamero.com" property=og:title> <meta content="Nesse post, discutiremos como separar as lógicas de renderização e de domínio usando React e Redux :]" property=og:description> <meta content=https://www.ratamero.com/default-media-share.jpg property=og:image> <meta content=https://www.ratamero.com property=og:url> <meta content="Desacoplando a lógica de componentes React - luciano@ratamero.com" name=twitter:title> <meta content="Nesse post, discutiremos como separar as lógicas de renderização e de domínio usando React e Redux :]" name=twitter:description> <meta content=https://www.ratamero.com/default-media-share.jpg name=twitter:image> <meta content=summary_large_image name=twitter:card> <link href=https://fonts.gstatic.com rel=preconnect> <link href="https://fonts.googleapis.com/css2?family=Source+Sans+Pro:ital,wght@0,400;0,700;1,400&display=swap" rel=stylesheet> <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono&display=swap" rel=stylesheet> <link href=/client/client.311a5b93.js rel=modulepreload as=script crossorigin=use-credentials><link href=/client/client-a688d852.css rel=preload as=style><link href=/client/index.cb3a59a9.js rel=modulepreload as=script crossorigin=use-credentials><link href=/client/Icon.06acf308.js rel=modulepreload as=script crossorigin=use-credentials><link href=/client/MetaTags.39c5eacd.js rel=modulepreload as=script crossorigin=use-credentials><link href=/client/index.ec9d7c60.js rel=modulepreload as=script crossorigin=use-credentials><link href=/client/cover.e41aed43.js rel=modulepreload as=script crossorigin=use-credentials><link href=/client/inject_styles.5607aec6.js.gz rel=modulepreload as=script crossorigin=use-credentials><link href=/client/Icon-dfea4060.css rel=preload as=style></head> <body> <div id=sapper> <section class="light-theme theme"><section class="loading-overlay svelte-1rtsid8"><div class="circle svelte-gkf9c4" style=--size:60px;--colorInner:#676778;--colorCenter:#40B3FF;--colorOuter:#FF3E00></div></section> <section class=transition-wrapper><main><article class=blog-post> <h1><mark>Desacoplando a lógica de componentes React</mark></h1> <p class=meta>2019-07-23 </p> <figure><img alt="Ilustração com as logos do React e do Redux" src=/client/da96744abab4691a.png></figure> <p><em>for native english speakers, <a href=/en/decoupling-logic-from-react-components/ >here's the translated post</a></em></p> <article><p>Sempre que há um novo projeto baseado em React, grande parte dos devs frontend irão passar pelo ritual de configuração inicial. Padrões de implementação de estilos, desacoplamento de componentes e estrutura de diretórios irão emergir - <strong>nem sempre pro bem</strong>. O pior é que todo dev frontend que eu já vi irá resolver o maior problema de todos, o problema de desacoplar lógica de negócio, de uma forma diferente. Em um esforço para criar uma padronização e resolver a questão da camada de domínio aqui na Labcodes, eu pesquisei um bocado e achei uma forma boa e sustentável para lidar com requisições e processamento de dados. O resultado: react-redux-api-tools. </p> <h2>Vamos imaginar um cenário comum: CRUD</h2> <p>Já que o javascript é muito permissivo, há inúmeras maneiras de implementarmos um CRUD em uma SPA. Se limitarmos o escopo ao uso do react, as coisas ficam mais fáceis, mas ainda há possíveis implementações demais. Uma delas é de usar os hooks de ciclo de vida para fazer as requisições. Seu código provavelmente irá ficar parecido com isso: </p> <pre class=hljs><code><span class=hljs-keyword>export</span> <span class=hljs-keyword>default</span> <span class=hljs-class><span class=hljs-keyword>class</span> <span class=hljs-title>Product</span> <span class=hljs-keyword>extends</span> <span class=hljs-title>React</span>.<span class=hljs-title>Component</span> </span>{</code><br><code>  <span class=hljs-comment>// ...</span></code><br><code>  componentDidMount() {</code><br><code>    fetch(<span class=hljs-string>"/api/products/1/"</span>)</code><br><code>      .then(<span class=hljs-function><span class=hljs-params>response</span> =></span> response.json())</code><br><code>      .then(<span class=hljs-function><span class=hljs-params>data</span> =></span> <span class=hljs-keyword>this</span>.setState({...data}));</code><br><code>  }</code><br><code>  <span class=hljs-comment>//...</span></code><br><code>}</code></pre> <p>Eu acho que não preciso falar muito sobre isso, mas vou falar de qualquer forma: essa implementação, mesmo sendo perfeitamente válida, tem alguns <strong>grandes</strong> problemas. </p> <p>1.A requisição está sendo feita dentro do componente que, em teoria, deveria ter apenas um trabalho: <strong>renderizar os dados</strong>. Se, por exemplo, você precisasse limpar a sessão do usuário ou executar qualquer lógica de negócio, ela provavelmente estaria aqui, o que é <strong>ainda pior</strong>;<br> 2. Os dados da resposta da requisição está vivendo dentro do estado do componente, e isso significa que tudo será perdido assim que o componente desmontar;<br> 3. Você terá <strong>sempre</strong> que pegar os dados da API para cada instância do componente, mesmo que já tenha feito essa específica requisição um bilhão de vezes;<br> 4. Não há nenhum estado intermediário entre o início da requisição e sua resposta, então nada de spinners de loading (apesar de você poder implementar essa lógica construindo um <em>callback hell</em> de setStates);<br> 5. Já que componentes react são hierárquicos, se você precisar desses dados dentro de um componente filho ou pai, você terá que implementar contextos/props e callbacks. <strong>O código fica complicado. RAPIDINHO.</strong><br></p> <p>Para melhorar esse código, muitos de nós preferem usar uma biblioteca para prover um estado mais global para a aplicação; um estado que vive fora de todos os componentes. </p> <h2>Segundo passo: usando Redux</h2> <p>Redux é uma das melhores bibliotecas para esse tipo de trabalho. Digamos que você vai usar redux para lidar com dados e lógica de negócio. Assumindo que você usará a camada de reducers para formatar dados e chamar lógicas de domínio, seu componente vai ficar mais ou menos assim: </p> <pre class=hljs><code><span class=hljs-keyword>export</span> <span class=hljs-keyword>default</span> <span class=hljs-class><span class=hljs-keyword>class</span> <span class=hljs-title>Product</span> <span class=hljs-keyword>extends</span> <span class=hljs-title>React</span>.<span class=hljs-title>Component</span> </span>{</code><br><code>  <span class=hljs-comment>// ...</span></code><br><code>  componentDidMount() {</code><br><code>    <span class=hljs-keyword>const</span> { fetchProductIsLoading, setProductData } = <span class=hljs-keyword>this</span>.props;</code><br><code>    <span class=hljs-comment>// liga o spinner de loading via redux</span></code><br><code>    fetchProductIsLoading();</code><br><code></code><br><code>    <span class=hljs-comment>// faz a requisição e coloca os dados na store do redux</span></code><br><code>    fetch(<span class=hljs-string>"/api/products/1/"</span>)</code><br><code>      .then(<span class=hljs-function><span class=hljs-params>response</span> =></span> response.json())</code><br><code>      .then(<span class=hljs-function><span class=hljs-params>data</span> =></span> setProductData(data));</code><br><code>  }</code><br><code>  <span class=hljs-comment>//...</span></code><br><code>  render() {</code><br><code>    <span class=hljs-keyword>const</span> { productIsLoading, productData } = <span class=hljs-keyword>this</span>.props;</code><br><code>    <span class=hljs-comment>// ...</span></code><br><code>  }</code><br><code>}</code></pre> <p>Isso resolve grande parte dos problemas, mas eu diria que essa solução acopla ainda mais o código e, certeza, deixa ele mais difícil de ler e manter. A causa raiz disso tudo é o fato de que o componente está sendo responsável por absolutamente tudo: pegar os dados da API e orquestrar eventos do redux, quando era para ele estar… renderizando coisas. O fluxo ideal para resolver todos os problemas, pelo menos os mais importantes, seria algo similar a isso: </p> <ul class=callout><li>Componente monta e levanta sinal de isLoading pro Redux</li> <li>Action do Redux começa a requisição e dispara reducer de isLoading</li> <li>Componente renderiza isLoading</li> <li>Requisição termina assincronamente e dispara reducer de sucesso ou falha </li> <li>Componente renderiza sucesso ou falha</ul> <p>Note que a única forma de completamente remover a lógica de negócio dos componentes é acionando os casos de uso de ‘Sucesso’ e ‘Falha’ <strong>fora do componente</strong>. Componentes devem renderizar coisas, não lidar com gerenciamento de estado da <strong>aplicação inteira</strong>. Isso significa que o componente apenas deve avisar a alguém que precisa de dados, disparando um evento (o evento de ‘pega esses dados pra mim’), e então reagir aos dados quando eles estiverem lá. Para respeitar essa ideia, nosso código do componente deveria ser tão simples quanto isso: </p> <pre class=hljs><code><span class=hljs-keyword>export</span> <span class=hljs-keyword>default</span> <span class=hljs-class><span class=hljs-keyword>class</span> <span class=hljs-title>Product</span> <span class=hljs-keyword>extends</span> <span class=hljs-title>React</span>.<span class=hljs-title>Component</span> </span>{</code><br><code>  <span class=hljs-comment>// ...</span></code><br><code>  componentDidMount() {</code><br><code>    <span class=hljs-keyword>const</span> { fetchProduct } = <span class=hljs-keyword>this</span>.props;</code><br><code>    fetchProduct();</code><br><code>  }</code><br><code>  <span class=hljs-comment>//...</span></code><br><code>  render() {</code><br><code>    <span class=hljs-keyword>const</span> { productIsLoading, productData } = <span class=hljs-keyword>this</span>.props;</code><br><code>    <span class=hljs-comment>// ...</span></code><br><code>  }</code><br><code>}</code></pre> <p>E isso significa que… as actions devem fazer a requisição dos dados? E reducers iriam disparar outras ações? Soa estranho, né? Porque é. E não é o que eu estou sugerindo <strong>mesmo</strong>. </p> <h2>Eis que chegam os middlewares</h2> <p>Para entregarmos o fluxo ideal de dados, <strong>middlewares do redux são maravilhosos</strong>. Imaginem que queremos que nosso componente seja exatamente como o código que vimos acima. Se nós, por exemplo, tivéssemos algo entre as actions e os reducers, a gente conseguiria fazer com que esse <em>código do meio</em> <strong>fizesse a requisição</strong> e, dependendo do resultado, <strong>decidisse quais reducers disparar</strong>. Assim, deixaríamos o redux livre para fazer seu trabalho de gerenciar o estado da aplicação e lidar com eventos, enquanto os componentes focariam em renderizar coisas - <strong>somente</strong> renderizar coisas. Estou falando sobre algo como isso aqui: </p> <ul class=callout><li>Componente monta e levanta sinal de iniciar a requisição pro Redux</li> <li>Action do Redux descreve reducers de sucesso e falha e declara função que faz a requisição </li> <li><strong>Middleware chama a função da requisição, guarda a promise e dispara reducer de isLoading</strong></li> <li>Componente renderiza isLoading</li> <li><strong>Middleware escuta a requisição e chama reducer de sucesso ou falha baseado na descrição da action</strong></li> <li>Reducer de sucesso ou falha executa código de lógica de negócio e persiste dados na store </li> <li>Componente renderiza sucesso ou falha</ul> <p>Com esse fluxo proposto, nossas actions poderiam ser mais ou menos assim: </p> <pre class=hljs><code><span class=hljs-keyword>export</span> <span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>fetchProduct</span>(<span class=hljs-params>id</span>) </span>{</code><br><code>  <span class=hljs-keyword>return</span> {</code><br><code>    <span class=hljs-attr>types</span>: {</code><br><code>      <span class=hljs-attr>request</span>: FETCH_PRODUCT_REQUEST,</code><br><code>      <span class=hljs-attr>success</span>: FETCH_PRODUCT_SUCCESS,</code><br><code>      <span class=hljs-attr>failure</span>: FETCH_PRODUCT_FAILURE,</code><br><code>    },</code><br><code>    <span class=hljs-attr>apiCallFunction</span>: <span class=hljs-function><span class=hljs-params>()</span> =></span> fetch(<span class=hljs-string>`/api/products/<span class=hljs-subst>${id}</span>`</span>),</code><br><code>  }</code><br><code>}</code></pre> <p>Ok, vamos com calma. O que você está vendo aí em cima é a nossa convenção atual que descreve uma <em>action de requisição</em>, que usa o middleware incluído no nosso pacote npm <a href=https://www.npmjs.com/package/react-redux-api-tools rel=noopener target=_blank><code>react-redux-api-tools</code></a>. Fazer o dispatch dessa action <strong>configura</strong> o middleware para <strong>fazer a requisição</strong> (ao chamar a <code>apiCallFunction</code>) e para <strong>usar o reducer correto</strong> assim que a requisição estiver concluída. Enquanto isso, nossos componentes e reducers se manteriam inalterados: </p> <pre class=hljs><code><span class=hljs-keyword>export</span> <span class=hljs-keyword>default</span> <span class=hljs-class><span class=hljs-keyword>class</span> <span class=hljs-title>Product</span> <span class=hljs-keyword>extends</span> <span class=hljs-title>React</span>.<span class=hljs-title>Component</span> </span>{</code><br><code>  <span class=hljs-comment>// ...</span></code><br><code>  componentDidMount() {</code><br><code>    <span class=hljs-keyword>const</span> { fetchProduct } = <span class=hljs-keyword>this</span>.props;</code><br><code>    fetchProduct();</code><br><code>  }</code><br><code>  <span class=hljs-comment>//...</span></code><br><code>  render() {</code><br><code>    <span class=hljs-keyword>const</span> { productIsLoading, productData } = <span class=hljs-keyword>this</span>.props;</code><br><code>    <span class=hljs-comment>// ...</span></code><br><code>  }</code><br><code>}</code></pre> <pre class=hljs><code><span class=hljs-keyword>export</span> <span class=hljs-keyword>const</span> productReducer = <span class=hljs-function>(<span class=hljs-params>state = initialState, action</span>) =></span> {</code><br><code>  <span class=hljs-keyword>switch</span>(action.type) {</code><br><code>    <span class=hljs-keyword>case</span> FETCH_PRODUCT_REQUEST:</code><br><code>      <span class=hljs-keyword>return</span> {</code><br><code>        ...state,</code><br><code>        <span class=hljs-attr>error</span>: <span class=hljs-literal>null</span>,</code><br><code>        <span class=hljs-attr>productIsLoading</span>: <span class=hljs-literal>true</span>,</code><br><code>      }</code><br><code>    <span class=hljs-keyword>case</span> FETCH_PRODUCT_SUCCESS:</code><br><code>      <span class=hljs-comment>// aqui, você pode executar qualquer lógica de negócio</span></code><br><code>      businessLogic();</code><br><code></code><br><code>      <span class=hljs-keyword>return</span> {</code><br><code>        ...state,</code><br><code>        <span class=hljs-attr>error</span>: <span class=hljs-literal>null</span>,</code><br><code>        <span class=hljs-attr>productIsLoading</span>: initialState.productIsLoading,</code><br><code>        <span class=hljs-attr>productData</span>: action.response.data,</code><br><code>      }</code><br><code>    <span class=hljs-keyword>case</span> FETCH_PRODUCT_FAILURE:</code><br><code>      <span class=hljs-keyword>return</span> {</code><br><code>        ...state,</code><br><code>        <span class=hljs-attr>productIsLoading</span>: initialState.productIsLoading,</code><br><code>        <span class=hljs-attr>error</span>: action.response.data,</code><br><code>      }</code><br><code>    <span class=hljs-attr>default</span>:</code><br><code>      <span class=hljs-keyword>return</span> state;</code><br><code>  }</code><br><code>}</code></pre> <p>E <em>voilá,</em> nosso fluxo está bem mais limpo, simples e desacoplado! </p> <h2>Se você gostou disso ou isso parece mágico demais…</h2> <p>Gostou na API desse middleware? Quer desenvolver seus projetos react-redux dessa maneira? Está curiosa para saber como tudo isso funciona por baixo dos panos? Então você é uma pessoa que poderia usar e contribuir com nosso pacote npm <a href=https://www.npmjs.com/package/react-redux-api-tools>react-redux-api-tools</a>. Reportagem de bugs e sugestões de features são bem vindas! E isso tudo é só o começo; <a href=https://www.npmjs.com/package/react-redux-api-tools>react-redux-api-tools</a> traz um monte de outras features que não consegui descrever nesse post. Dê uma boa olhada na nossa documentação para descobrir como melhorar e simplificar seu código usando nossas ferramentas! Obrigado, e até a próxima! </article></article></main></section> <nav class=svelte-1kh6syz><ul class=svelte-1kh6syz><li class=svelte-1kh6syz><a href=/ rel=prefetch class=svelte-1kh6syz>about</a></li> <li class=svelte-1kh6syz><a href=blog/page/1 rel=prefetch class=svelte-1kh6syz aria-current=page>blog</a></li> <li class=svelte-1kh6syz><a href=previous-talks rel=prefetch class=svelte-1kh6syz>talks</a></ul> </nav> </section></div> <script> document.addEventListener('readystatechange', function () {
			if (document.readyState === 'interactive') {
				// set theme
				document.getElementsByClassName('theme')[0].classList = window.matchMedia &&
					window.matchMedia("(prefers-color-scheme: dark)").matches
					? "theme dark-theme"
					: "theme light-theme";

				// fix height on chrome mobile
				let vh = window.innerHeight * 0.01;
				// Then we set the value in the --vh custom property to the root of the document
				document.documentElement.style.setProperty("--vh", `${vh}px`);

				const isChrome = navigator.userAgent.indexOf("Chrome") > -1;
				if (isChrome) {
					document.getElementsByClassName("theme")[0].style["min-height"] =
						"calc(var(--vh, 1vh) * 100)";
				}

				// We listen to the resize event
				window.addEventListener("resize", () => {
					// We execute the same script as before
					let vh = window.innerHeight * 0.01;
					document.documentElement.style.setProperty("--vh", `${vh}px`);

					if (isChrome) {
						document.getElementsByClassName("theme")[0].style["min-height"] =
							"calc(var(--vh, 1vh) * 100)";
					}
				});
			}
		}); </script> 