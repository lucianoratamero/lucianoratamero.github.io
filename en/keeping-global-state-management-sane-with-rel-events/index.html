<!doctype html> <html lang=en> <head> <meta charset=utf-8> <meta content="width=device-width,initial-scale=1" name=viewport> <meta content=#333333 name=theme-color> <base href=/ > <link href=manifest.json rel=manifest crossorigin=use-credentials> <link href=favicon.png rel=icon type=image/png> <script>__SAPPER__={baseUrl:"",preloaded:[void 0,{},{}]};if('serviceWorker' in navigator)navigator.serviceWorker.register('/service-worker.js');(function(){try{eval("async function x(){}");var main="/client/client.311a5b93.js"}catch(e){main="/client/legacy/client.eda691f8.js"};var s=document.createElement("script");try{new Function("if(0)import('')")();s.src=main;s.type="module";s.crossOrigin="use-credentials";}catch(e){s.src="/client/shimport@2.0.4.js";s.setAttribute("data-main",main);}document.head.appendChild(s);}());</script> <link href=client/client-a688d852.css rel=stylesheet><link href=client/Icon-dfea4060.css rel=stylesheet> <style>.hljs-comment,.hljs-quote{color:#969896}.hljs-deletion,.hljs-name,.hljs-regexp,.hljs-selector-class,.hljs-selector-id,.hljs-tag,.hljs-template-variable,.hljs-variable{color:#d54e53}.hljs-built_in,.hljs-builtin-name,.hljs-link,.hljs-literal,.hljs-meta,.hljs-number,.hljs-params,.hljs-type{color:#e78c45}.hljs-attribute{color:#e7c547}.hljs-addition,.hljs-bullet,.hljs-string,.hljs-symbol{color:#b9ca4a}.hljs-section,.hljs-title{color:#7aa6da}.hljs-keyword,.hljs-selector-tag{color:#c397d8}.hljs{display:block;overflow-x:auto;background:#000;color:#eaeaea;padding:.5em}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><title>Keeping global state management sane with rel-events - luciano@ratamero.com</title> <meta content="In this post, we'll discuss how to use rel-events to keep your React app's state sane :]" name=description> <meta content="Luciano Ratamero, rel-events, react, redux, big projects, architecture, planning, frontend, javascript, frameworks" name=keywords> <meta content="Keeping global state management sane with rel-events - luciano@ratamero.com" property=og:title> <meta content="In this post, we'll discuss how to use rel-events to keep your React app's state sane :]" property=og:description> <meta content=https://www.ratamero.com/default-media-share.jpg property=og:image> <meta content=https://www.ratamero.com property=og:url> <meta content="Keeping global state management sane with rel-events - luciano@ratamero.com" name=twitter:title> <meta content="In this post, we'll discuss how to use rel-events to keep your React app's state sane :]" name=twitter:description> <meta content=https://www.ratamero.com/default-media-share.jpg name=twitter:image> <meta content=summary_large_image name=twitter:card> <link href=https://fonts.gstatic.com rel=preconnect> <link href="https://fonts.googleapis.com/css2?family=Source+Sans+Pro:ital,wght@0,400;0,700;1,400&display=swap" rel=stylesheet> <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono&display=swap" rel=stylesheet> <link href=/client/client.311a5b93.js rel=modulepreload as=script crossorigin=use-credentials><link href=/client/client-a688d852.css rel=preload as=style><link href=/client/index.46e89bda.js rel=modulepreload as=script crossorigin=use-credentials><link href=/client/Icon.06acf308.js rel=modulepreload as=script crossorigin=use-credentials><link href=/client/MetaTags.39c5eacd.js rel=modulepreload as=script crossorigin=use-credentials><link href=/client/index.ec9d7c60.js rel=modulepreload as=script crossorigin=use-credentials><link href=/client/cover.4038dd1b.js rel=modulepreload as=script crossorigin=use-credentials><link href=/client/inject_styles.5607aec6.js.gz rel=modulepreload as=script crossorigin=use-credentials><link href=/client/Icon-dfea4060.css rel=preload as=style></head> <body> <div id=sapper> <section class="light-theme theme"><section class="loading-overlay svelte-1rtsid8"><div class="circle svelte-gkf9c4" style=--size:60px;--colorInner:#676778;--colorCenter:#40B3FF;--colorOuter:#FF3E00></div></section> <section class=transition-wrapper><main><article class=blog-post> <h1><mark>Keeping global state management sane with rel-events</mark></h1> <p class=meta>2019-10-19 </p> <figure><img alt="Logos from React and Redux" src=/client/71a9ff9732f6eb60.png></figure> <article><p>Maintaining a big and complex react app is not for amateurs. Whatever you may choose to manage your app state, chances are that it's hard to pick up, like redux, or really convoluted, like making yourself a service layer. With the goal of making it easy for new developers to jump into our projects, we at Labcodes decided it was time to give this problem a little more thought. Our answer was <a href=https://github.com/labcodes/rel-events>rel-events</a>. </p> <h2>Why another library to manage states?</h2> <p><a href=https://xkcd.com/927/ ><img alt="xkcd is always right" src=https://imgs.xkcd.com/comics/standards.png></a></p> <p>Whenever I think of making something new and shiny, this xkcd strip comes to haunt me. Believe me, I don't want to be the kind of person that does everything themselves, and that's one of my grievances with the fork mentality. However, it was about time I did something to address a pesky problem I deal with daily: using whatever library to separate business logic from react components. </p> <p>At the end of the day, after much thought, I always end up surrendering and running <code>npm install redux react-redux --save</code>. I even shared my basic tools to deal with redux on our <a href=https://github.com/labcodes/react-redux-api-tools/ ><code>react-redux-api-tools</code></a> package. </p> <p>And by no means I hate redux; in fact, I love it. It gets the job done, it's ultra flexible, with low side effects. But let's be frank here: the discomfort of reading <code>mapStateToProps</code> for the first time is <strong>real</strong>. It took me a long while to properly understand what was going on. Then there are actions, action creators, reducers, dispatches and middlewares, and sagas, and async dispatches; it's neverending. </p> <p>After those confusing and long first months, things started to get easier, but way, <strong>way</strong> too verbose. I always thought that redux felt a lower level tool, and that I was always in need of specifying, step by step, exactly and strictly what and how things should be done. No abstraction at all. A lot of copy and paste, though. </p> <p>I came to the conclusion that it would be nice to have all the features I would like in my redux configuration - a proper HTTP request flow, less repetition, meaningful connection between actions and reducers -, without sacrificing anything. I got the green light to develop internally a solution for that: <code>rel-events</code>. </p> <h2>Cool, but what's <code>rel-events</code>?</h2> <p><code>rel-events</code> is a React Events Library that takes the concept of events, present in redux, to a higher level of abstraction. It's a thin layer over redux that enables you to stop thinking about actions, reducers, stores and middlewares, so you can focus on what needs to be done: executing domain logic reactively when events pop up. </p> <p>To do that, let's imagine a simple scenario: we need to enable a user to log into our app. </p> <p>You could do the whole request flow inside your components, but <a href=https://labcodes.com.br/blog/en/decoupling-logic-from-react-components.html>as we stated on our previous blog post</a>, we don't really recommend doing that - it always ends up messy. We could use redux, but then our junior developers would need to pass that <code>mapStateToProps</code> hurdle, and sometimes we don't have the luxury of taking our time. We could use sagas, but then redux is back with a vengeance. </p> <p>Now, forget about actions and reducers and imagine we have an object called LoginEvent. Whenever we call it passing an email and password, things get done and data comes through to the component. Imagine you don't need to know anything but its name. No reducers, no actions, no <code>connect</code> or <code>mapStateToProps</code>. It would be something like this: </p> <pre class=hljs><code><span class=hljs-keyword>import</span> { HTTPEvent } <span class=hljs-keyword>from</span> <span class=hljs-string>"rel-events"</span>;</code><br><code></code><br><code><span class=hljs-keyword>export</span> <span class=hljs-keyword>const</span> LoginEvent = <span class=hljs-keyword>new</span> HTTPEvent({ <span class=hljs-attr>name</span>: <span class=hljs-string>"login"</span> });</code></pre> <p>Cool, but what about the whole behavior? Where's the logic to make the request? How to deal with bad requests? Let's say, besides the Event, we have something that manages the event flow, an Event Manager: </p> <pre class=hljs><code><span class=hljs-keyword>import</span> { HTTPEvent } <span class=hljs-keyword>from</span> <span class=hljs-string>"rel-events"</span>;</code><br><code><span class=hljs-keyword>import</span> { LoginEventManager } <span class=hljs-keyword>from</span> <span class=hljs-string>"./eventManagers"</span>;</code><br><code></code><br><code><span class=hljs-keyword>export</span> <span class=hljs-keyword>const</span> LoginEvent = <span class=hljs-keyword>new</span> HTTPEvent({</code><br><code>  <span class=hljs-attr>name</span>: <span class=hljs-string>"login"</span>,</code><br><code>  <span class=hljs-attr>manager</span>: <span class=hljs-keyword>new</span> LoginEventManager(),</code><br><code>});</code></pre> <p>That's better. But how is this manager implemented? Because, if it needs to deal with the event flow, it needs to do a lot of stuff: know how to make the request and what to do when the request succeeds or fails. Oh, and we need an intermediary state, because we love loading spinners! Hell, I forgot about the inital state of the event as well! Ok, ok, let's see: </p> <pre class=hljs><code><span class=hljs-keyword>import</span> { fetchFromApi } <span class=hljs-keyword>from</span> <span class=hljs-string>"rel-events"</span>;</code><br><code></code><br><code><span class=hljs-keyword>export</span> <span class=hljs-class><span class=hljs-keyword>class</span> <span class=hljs-title>LoginEventManager</span> </span>{</code><br><code>  initialState = { <span class=hljs-attr>isLoading</span>: <span class=hljs-literal>false</span>, <span class=hljs-attr>username</span>: <span class=hljs-string>"Anonymous"</span> };</code><br><code></code><br><code>  call = <span class=hljs-function>(<span class=hljs-params>user</span>) =></span> {</code><br><code>    <span class=hljs-keyword>return</span> <span class=hljs-function><span class=hljs-params>()</span> =></span> fetchFromApi(</code><br><code>      <span class=hljs-string>"/api/login"</span>,</code><br><code>      { <span class=hljs-attr>method</span>: <span class=hljs-string>"POST"</span>, <span class=hljs-attr>body</span>: <span class=hljs-built_in>JSON</span>.stringify(user) }</code><br><code>    );</code><br><code>  }</code><br><code></code><br><code>  onDispatch = <span class=hljs-function>(<span class=hljs-params>state, event</span>) =></span> ({</code><br><code>    ...state,</code><br><code>    <span class=hljs-attr>isLoading</span>: <span class=hljs-literal>true</span>,</code><br><code>    <span class=hljs-attr>username</span>: <span class=hljs-keyword>this</span>.initialState.username</code><br><code>  })</code><br><code></code><br><code>  onSuccess = <span class=hljs-function>(<span class=hljs-params>state, event</span>) =></span> ({</code><br><code>    ...state,</code><br><code>    <span class=hljs-attr>isLoading</span>: <span class=hljs-keyword>this</span>.initialState.isLoading,</code><br><code>    <span class=hljs-attr>username</span>: event.response.data.username</code><br><code>  })</code><br><code></code><br><code>  onFailure = <span class=hljs-function>(<span class=hljs-params>state, event</span>) =></span> ({</code><br><code>    ...state,</code><br><code>    <span class=hljs-attr>isLoading</span>: <span class=hljs-keyword>this</span>.initialState.isLoading,</code><br><code>    <span class=hljs-attr>username</span>: <span class=hljs-keyword>this</span>.initialState.username,</code><br><code>    <span class=hljs-attr>error</span>: event.error.data</code><br><code>  })</code><br><code>});</code></pre> <p>That's about it, right? But, hey, how do we trigger it? And how do I make the Event register which Components are able to trigger it? How does the component get the data from it? We're almost there: </p> <pre class=hljs><code><span class=hljs-comment>// LoginComponent.js</span></code><br><code><span class=hljs-keyword>import</span> React <span class=hljs-keyword>from</span> <span class=hljs-string>"react"</span>;</code><br><code><span class=hljs-keyword>import</span> { LoginEvent } <span class=hljs-keyword>from</span> <span class=hljs-string>"./events"</span>;</code><br><code></code><br><code><span class=hljs-keyword>export</span> <span class=hljs-class><span class=hljs-keyword>class</span> <span class=hljs-title>LoginComponent</span> <span class=hljs-keyword>extends</span> <span class=hljs-title>React</span>.<span class=hljs-title>Component</span> </span>{</code><br><code>  handleSubmit = <span class=hljs-function><span class=hljs-params>()</span> =></span> {</code><br><code>    <span class=hljs-keyword>const</span> { user } = <span class=hljs-keyword>this</span>.state;</code><br><code>    <span class=hljs-comment>// the Event injects its trigger as a prop with its own name ("login")</span></code><br><code>    <span class=hljs-keyword>const</span> { login } = <span class=hljs-keyword>this</span>.props;</code><br><code></code><br><code>    login(user);</code><br><code>  }</code><br><code></code><br><code>  render() {</code><br><code>    <span class=hljs-keyword>const</span> { username } = <span class=hljs-keyword>this</span>.props;</code><br><code>    <span class=hljs-keyword>return</span> (</code><br><code>      &lt;React.Fragment></code><br><code>        &lt;h1>Hello, {username}&lt;/h1></code><br><code>        &lt;form>{ /* inputs and submit button */ }&lt;/form></code><br><code>      &lt;/React.Fragment></code><br><code>    );</code><br><code>  }</code><br><code>});</code><br><code></code><br><code><span class=hljs-comment>// and here, we register the Component in the Event,</span></code><br><code><span class=hljs-comment>// which injects its trigger as props (as described above),</span></code><br><code><span class=hljs-comment>// and we also ask for the Events "username" value to be injected as well</span></code><br><code><span class=hljs-keyword>export</span> <span class=hljs-keyword>default</span> LoginEvent.register({</code><br><code>  <span class=hljs-attr>Component</span>: LoginComponent,</code><br><code>  <span class=hljs-attr>props</span>: [<span class=hljs-string>"username"</span>]</code><br><code>});</code></pre> <p>And that's exactly the current API for a HTTPEvent from <code>rel-events</code>. No actions, no reducers, no coupling between the logic and the component layers, nothing. Of course, it needs some configuration to hook it up with redux, but it's mostly a one time setup, very well documented <a href=https://github.com/labcodes/rel-events/tree/master/docs>in our docs</a>. </p> <h2>That sounds... nice! But what about features? I want features!</h2> <p>With our current beta version (0.1.3 as of September 2019), you're able to: </p> <ul><li>use a basic Event type (for the times you don't need to make HTTP requests); </li> <li>chain Events/HTTPEvents (useful for fetching more data when a request is done); </li> <li>have multiple Events registering to the same Component (you'll probably have a Component that needs to listen to multiple Events); </li> <li>execute code after dispatching an Event (with <code>afterDispatch</code>); </li> <li>execute code after a request is successful (with <code>afterSuccess</code>); </li> <li>execute code after a request has failed (with <code>afterFailure</code>); </li> <li>evaluate if an event should be dispatched or not (with the <code>shouldDispatch</code> method). </ul> <p>And more! All that without the cognitive burden, the crazy constants, the store names and all the bad developer experience from redux. The best part: no huge learning curve. This post has basically all you need to know to use our lib. Really. </p> <p>So if you liked it, <a href=https://github.com/labcodes/rel-events>take a look at our github repo</a> to get started and share the love! Thanks for your attention, and see you next time! </article></article></main></section> <nav class=svelte-1kh6syz><ul class=svelte-1kh6syz><li class=svelte-1kh6syz><a href=/ class=svelte-1kh6syz rel=prefetch>about</a></li> <li class=svelte-1kh6syz><a href=blog/page/1 class=svelte-1kh6syz rel=prefetch>blog</a></li> <li class=svelte-1kh6syz><a href=previous-talks class=svelte-1kh6syz rel=prefetch>talks</a></ul> </nav> </section></div> <script> document.addEventListener('readystatechange', function () {
			if (document.readyState === 'interactive') {
				// set theme
				document.getElementsByClassName('theme')[0].classList = window.matchMedia &&
					window.matchMedia("(prefers-color-scheme: dark)").matches
					? "theme dark-theme"
					: "theme light-theme";

				// fix height on chrome mobile
				let vh = window.innerHeight * 0.01;
				// Then we set the value in the --vh custom property to the root of the document
				document.documentElement.style.setProperty("--vh", `${vh}px`);

				const isChrome = navigator.userAgent.indexOf("Chrome") > -1;
				if (isChrome) {
					document.getElementsByClassName("theme")[0].style["min-height"] =
						"calc(var(--vh, 1vh) * 100)";
				}

				// We listen to the resize event
				window.addEventListener("resize", () => {
					// We execute the same script as before
					let vh = window.innerHeight * 0.01;
					document.documentElement.style.setProperty("--vh", `${vh}px`);

					if (isChrome) {
						document.getElementsByClassName("theme")[0].style["min-height"] =
							"calc(var(--vh, 1vh) * 100)";
					}
				});
			}
		}); </script> 