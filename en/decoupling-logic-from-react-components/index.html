<!doctype html> <html lang=en> <head> <meta charset=utf-8> <meta content="width=device-width,initial-scale=1" name=viewport> <meta content=#333333 name=theme-color> <base href=/ > <link href=manifest.json rel=manifest crossorigin=use-credentials> <link href=favicon.png rel=icon type=image/png> <script>__SAPPER__={baseUrl:"",preloaded:[void 0,{},{}]};if('serviceWorker' in navigator)navigator.serviceWorker.register('/service-worker.js');(function(){try{eval("async function x(){}");var main="/client/client.ba4c128a.js"}catch(e){main="/client/legacy/client.b5ae4b81.js"};var s=document.createElement("script");try{new Function("if(0)import('')")();s.src=main;s.type="module";s.crossOrigin="use-credentials";}catch(e){s.src="/client/shimport@2.0.4.js";s.setAttribute("data-main",main);}document.head.appendChild(s);}());</script> <link href=client/client-2e2ca2b4.css rel=stylesheet> <title>Decoupling logic from react components - luciano@ratamero.com</title><style>.hljs{display:block;overflow-x:auto;padding:.5em;background:#1e1e1e;color:#dcdcdc}.hljs-keyword,.hljs-literal,.hljs-name,.hljs-symbol{color:#569cd6}.hljs-link{color:#569cd6;text-decoration:underline}.hljs-built_in,.hljs-type{color:#4ec9b0}.hljs-class,.hljs-number{color:#b8d7a3}.hljs-meta-string,.hljs-string{color:#d69d85}.hljs-regexp,.hljs-template-tag{color:#9a5334}.hljs-formula,.hljs-function,.hljs-params,.hljs-subst,.hljs-title{color:#dcdcdc}.hljs-comment,.hljs-quote{color:#57a64a;font-style:italic}.hljs-doctag{color:#608b4e}.hljs-meta,.hljs-meta-keyword,.hljs-tag{color:#9b9b9b}.hljs-template-variable,.hljs-variable{color:#bd63c5}.hljs-attr,.hljs-attribute,.hljs-builtin-name{color:#9cdcfe}.hljs-section{color:gold}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-bullet,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-id,.hljs-selector-pseudo,.hljs-selector-tag{color:#d7ba7d}.hljs-addition{background-color:#144212;display:inline-block;width:100%}.hljs-deletion{background-color:#600;display:inline-block;width:100%}</style><link href=https://fonts.gstatic.com rel=preconnect data-svelte=svelte-1vo6mso><link href="https://fonts.googleapis.com/css2?family=Poppins:ital,wght@0,400;0,500;0,700;1,400&display=swap" rel=stylesheet data-svelte=svelte-1vo6mso><link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono&display=swap" rel=stylesheet data-svelte=svelte-1vo6mso><meta content="In this post, we'll discuss how to decouple rendering from domain login using React and Redux :]" name=description data-svelte=svelte-1shf3cp><meta content="Luciano Ratamero, react, redux, big projects, architecture, planning, frontend, javascript, frameworks" name=keywords data-svelte=svelte-1shf3cp> <link href=/client/client.ba4c128a.js rel=modulepreload as=script crossorigin=use-credentials><link href=/client/client-2e2ca2b4.css rel=preload as=style><link href=/client/index.bd0a6ebe.js rel=modulepreload as=script crossorigin=use-credentials><link href=/client/image8.948aeaf3.js rel=modulepreload as=script crossorigin=use-credentials><link href=/client/inject_styles.5607aec6.js.gz rel=modulepreload as=script crossorigin=use-credentials></head> <body> <div id=sapper> <section class="dark-theme theme"><section class=transition-wrapper><main><article class=blog-post> <h1><mark>Decoupling logic from react components</mark></h1> <p class=meta>2019-07-23</p> <figure><img alt="Logos of React and Redux" src=/client/da96744abab4691a.png></figure> <p>Whenever there’s a new React project, most frontend developers will fumble around with the basic configurations. Patterns of style implementation, component decoupling and folder structure will emerge - <strong>not always for the good</strong>. The worst part is that every single frontend dev I’ve ever seen will solve the biggest problem of them all, the <em>business logic</em> conundrum, in a different way. In an effort to create a standard to solve the domain layer issue at Labcodes, I’ve researched a bit and found a good and sustainable way to deal with requests and data processing. The end result: react-redux-api-tools. </p> <h2>Let’s imagine a common scenario: CRUD</h2> <p>Since javascript is too permissive, there are endless ways to make a CRUD SPA. Limiting the scope to react helps a bit, but there are still way too many different possible implementations. One of them is to use lifecycle hooks to make requests. Your code may look a bit like this: </p> <figure><img alt="first code" src=/client/bf55ca4fb8dae401.png></figure> <p>I think I don’t need to say this, but I’ll do it anyway: this implementation, even though it’s completely valid, has some <strong>big</strong> drawbacks. </p> <p>1.The request is being made inside a component, which, in theory, should have only one job: <strong>render data</strong>. If, for example, you needed to clear out a user’s session or any other business logic, it would probably be here, and that’s <strong>even worse</strong>;<br> 2. The response data lives <strong>inside</strong> the component’s state, and that means that it’s gone as soon as the component unmounts;<br> 3. You’ll have to <strong>always</strong> fetch the data for each instance of the component, even if that specific request was already done a billion times;<br> 4. There is no specific middle state between the request start and the response, so no loading spinners (though you may be able to implement it using setState callback hells);<br> 5. Since react components are hierarchical, if you need this data inside a child or a parent component, you’ll need to implement contexts/props and callbacks. <strong>It gets messy. FAST.</strong><br></p> <p>To make it better, most of us prefer to use a library to provide a global application state; one that lives outside all components. </p> <h2>Second step: use Redux</h2> <p>Redux is one of the most amazing tools for the job. So let’s say you’re using redux to manage the data and business logic. Assuming you’ll be using the reducers to deal with business logic and data formatting, your component code will probably look a bit like this: </p> <figure><img alt="segundo código" src=/client/9927330c1f2226b6.png></figure> <p>This solves most of the issues, but I would argue that this solution makes everything <strong>even more coupled</strong> and, for sure, <strong>worse to read and maintain</strong>. The root cause of the issue is that the component is still being responsible for <strong>everything</strong>: fetching the data and orchestrating redux actions, when it’s only supposed to... render stuff. The ideal flow to solve all issues, <em>at least the best for most cases</em>, would be something akin to the following flowchart: </p> <figure><img alt="primeiro processo" src=/client/8b51b99255e147f2.png></figure> <p>Note that the only way to remove completely the business logic from the component is to trigger the ‘Success’ and ‘Failure’ use cases <strong>outside</strong> of the component. Components should render stuff, not deal with <strong>application-wide</strong> state management. That means that the component should only dispatch one event (the <em>‘get me the data’</em> event), then react to it whenever the data is there. For that, our component code would need to be as simple as this: </p> <figure><img alt="terceiro codigo" src=/client/01177a49d54d4b42.png></figure> <p>And that means that… the actions should fetch the data? And reducers would dispatch actions? Sounds weird, right? Because it is. And it’s not what I’m suggesting whatsoever. </p> <h2>Enter the middlewares</h2> <p>To deliver the ideal data flow, <strong>redux middlewares are amazing</strong>. Let’s say we want our component to be exactly like that last bit of code. If we had something in between actions and reducers, for example, we could make this <strong>inbetween</strong> code deal with fetching the data and figuring out which reducers to fire, leaving redux to do its job of managing state and events, while leaving components focused on their jobs of rendering, and rendering only. The data flow would be something like this: </p> <figure><img alt="segundo processo" src=/client/a747a129162662fb.png></figure> <p>With this proposed flow, our action could look like this:</p> <figure><img alt="quarto codigo" src=/client/b42b7dbe25a16292.png></figure> <p>Ok, let’s slow down. What you see above is the current API for a request action, using the middleware included in our <code>[react-redux-api-tools](https://www.npmjs.com/package/react-redux-api-tools)</code> npm package. Dispatching this action would configure the middleware to make the request (by calling <code>apiCallFunction</code>) and to use the correct reducer whenever the request is done. Meanwhile, our component and reducers would remain unaltered: </p> <figure><img alt="quinto codigo" src=/client/01177a49d54d4b42.png></figure> <figure><img alt="sexto codigo" src=/client/ece14c0a6c4418b4.png></figure> <p>And <em>voilá</em>, the flow is much cleaner, simpler and decoupled!</p> <h2>If you liked this or it seems too magical...</h2> <p>Have you enjoyed this middleware API, want to develop your react-redux app like this or are just curious on how this all works? Then consider using and contributing to our <a href=https://www.npmjs.com/package/react-redux-api-tools>react-redux-api-tools</a> npm package. Bugs and feature proposals are welcome! And this is only the start; <a href=https://www.npmjs.com/package/react-redux-api-tools>react-redux-api-tools</a> has a bunch of other features I’ve not talked about. Give our docs a good read to find out how to further improve and simplify your code using our tools! Thanks, and see you later! </article></main></section> <nav class=svelte-12rvnlo><ul class=svelte-12rvnlo><li class=svelte-12rvnlo><a href=/ class=svelte-12rvnlo rel=prefetch>about</a></li> <li class=svelte-12rvnlo><a href=blog class=svelte-12rvnlo rel=prefetch>blog</a></li> <li class=svelte-12rvnlo><a href=previous-talks class=svelte-12rvnlo rel=prefetch>talks</a></ul> </nav></section></div> 