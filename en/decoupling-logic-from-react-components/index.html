<!doctype html> <html lang=en> <head> <meta charset=utf-8> <meta content="width=device-width,initial-scale=1" name=viewport> <meta content=#333333 name=theme-color> <base href=/ > <link href=manifest.json rel=manifest crossorigin=use-credentials> <link href=favicon.png rel=icon type=image/png> <script>__SAPPER__={baseUrl:"",preloaded:[void 0,{},{}]};if('serviceWorker' in navigator)navigator.serviceWorker.register('/service-worker.js');(function(){try{eval("async function x(){}");var main="/client/client.311a5b93.js"}catch(e){main="/client/legacy/client.eda691f8.js"};var s=document.createElement("script");try{new Function("if(0)import('')")();s.src=main;s.type="module";s.crossOrigin="use-credentials";}catch(e){s.src="/client/shimport@2.0.4.js";s.setAttribute("data-main",main);}document.head.appendChild(s);}());</script> <link href=client/client-a688d852.css rel=stylesheet><link href=client/Icon-dfea4060.css rel=stylesheet> <style>.hljs-comment,.hljs-quote{color:#969896}.hljs-deletion,.hljs-name,.hljs-regexp,.hljs-selector-class,.hljs-selector-id,.hljs-tag,.hljs-template-variable,.hljs-variable{color:#d54e53}.hljs-built_in,.hljs-builtin-name,.hljs-link,.hljs-literal,.hljs-meta,.hljs-number,.hljs-params,.hljs-type{color:#e78c45}.hljs-attribute{color:#e7c547}.hljs-addition,.hljs-bullet,.hljs-string,.hljs-symbol{color:#b9ca4a}.hljs-section,.hljs-title{color:#7aa6da}.hljs-keyword,.hljs-selector-tag{color:#c397d8}.hljs{display:block;overflow-x:auto;background:#000;color:#eaeaea;padding:.5em}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><title>Decoupling logic from react components - luciano@ratamero.com</title> <meta content="In this post, we'll discuss how to decouple rendering from domain login using React and Redux :]" name=description> <meta content="Luciano Ratamero, react, redux, big projects, architecture, planning, frontend, javascript, frameworks" name=keywords> <meta content="Decoupling logic from react components - luciano@ratamero.com" property=og:title> <meta content="In this post, we'll discuss how to decouple rendering from domain login using React and Redux :]" property=og:description> <meta content=https://www.ratamero.com/default-media-share.jpg property=og:image> <meta content=https://www.ratamero.com property=og:url> <meta content="Decoupling logic from react components - luciano@ratamero.com" name=twitter:title> <meta content="In this post, we'll discuss how to decouple rendering from domain login using React and Redux :]" name=twitter:description> <meta content=https://www.ratamero.com/default-media-share.jpg name=twitter:image> <meta content=summary_large_image name=twitter:card> <link href=https://fonts.gstatic.com rel=preconnect> <link href="https://fonts.googleapis.com/css2?family=Source+Sans+Pro:ital,wght@0,400;0,700;1,400&display=swap" rel=stylesheet> <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono&display=swap" rel=stylesheet> <link href=/client/client.311a5b93.js rel=modulepreload as=script crossorigin=use-credentials><link href=/client/client-a688d852.css rel=preload as=style><link href=/client/index.be5afefb.js rel=modulepreload as=script crossorigin=use-credentials><link href=/client/Icon.06acf308.js rel=modulepreload as=script crossorigin=use-credentials><link href=/client/MetaTags.39c5eacd.js rel=modulepreload as=script crossorigin=use-credentials><link href=/client/index.ec9d7c60.js rel=modulepreload as=script crossorigin=use-credentials><link href=/client/cover.e41aed43.js rel=modulepreload as=script crossorigin=use-credentials><link href=/client/inject_styles.5607aec6.js.gz rel=modulepreload as=script crossorigin=use-credentials><link href=/client/Icon-dfea4060.css rel=preload as=style></head> <body> <div id=sapper> <section class="light-theme theme"><section class="loading-overlay svelte-1rtsid8"><div class="circle svelte-gkf9c4" style=--size:60px;--colorInner:#676778;--colorCenter:#40B3FF;--colorOuter:#FF3E00></div></section> <section class=transition-wrapper><main><article class=blog-post> <h1><mark>Decoupling logic from react components</mark></h1> <p class=meta>2019-07-23 </p> <figure><img alt="Logos of React and Redux" src=/client/da96744abab4691a.png></figure> <article><p>Whenever there’s a new React project, most frontend developers will fumble around with the basic configurations. Patterns of style implementation, component decoupling and folder structure will emerge - <strong>not always for the good</strong>. The worst part is that every single frontend dev I’ve ever seen will solve the biggest problem of them all, the <em>business logic</em> conundrum, in a different way. In an effort to create a standard to solve the domain layer issue at Labcodes, I’ve researched a bit and found a good and sustainable way to deal with requests and data processing. The end result: react-redux-api-tools. </p> <h2>Let’s imagine a common scenario: CRUD</h2> <p>Since javascript is too permissive, there are endless ways to make a CRUD SPA. Limiting the scope to react helps a bit, but there are still way too many different possible implementations. One of them is to use lifecycle hooks to make requests. Your code may look a bit like this: </p> <pre class=hljs><code><span class=hljs-keyword>export</span> <span class=hljs-keyword>default</span> <span class=hljs-class><span class=hljs-keyword>class</span> <span class=hljs-title>Product</span> <span class=hljs-keyword>extends</span> <span class=hljs-title>React</span>.<span class=hljs-title>Component</span> </span>{</code><br><code>  <span class=hljs-comment>// ...</span></code><br><code>  componentDidMount() {</code><br><code>    fetch(<span class=hljs-string>"/api/products/1/"</span>)</code><br><code>      .then(<span class=hljs-function><span class=hljs-params>response</span> =></span> response.json())</code><br><code>      .then(<span class=hljs-function><span class=hljs-params>data</span> =></span> <span class=hljs-keyword>this</span>.setState({...data}));</code><br><code>  }</code><br><code>  <span class=hljs-comment>//...</span></code><br><code>}</code></pre> <p>I think I don’t need to say this, but I’ll do it anyway: this implementation, even though it’s completely valid, has some <strong>big</strong> drawbacks. </p> <p>1.The request is being made inside a component, which, in theory, should have only one job: <strong>render data</strong>. If, for example, you needed to clear out a user’s session or any other business logic, it would probably be here, and that’s <strong>even worse</strong>;<br> 2. The response data lives <strong>inside</strong> the component’s state, and that means that it’s gone as soon as the component unmounts;<br> 3. You’ll have to <strong>always</strong> fetch the data for each instance of the component, even if that specific request was already done a billion times;<br> 4. There is no specific middle state between the request start and the response, so no loading spinners (though you may be able to implement it using setState callback hells);<br> 5. Since react components are hierarchical, if you need this data inside a child or a parent component, you’ll need to implement contexts/props and callbacks. <strong>It gets messy. FAST.</strong><br></p> <p>To make it better, most of us prefer to use a library to provide a global application state; one that lives outside all components. </p> <h2>Second step: use Redux</h2> <p>Redux is one of the most amazing tools for the job. So let’s say you’re using redux to manage the data and business logic. Assuming you’ll be using the reducers to deal with business logic and data formatting, your component code will probably look a bit like this: </p> <pre class=hljs><code><span class=hljs-keyword>export</span> <span class=hljs-keyword>default</span> <span class=hljs-class><span class=hljs-keyword>class</span> <span class=hljs-title>Product</span> <span class=hljs-keyword>extends</span> <span class=hljs-title>React</span>.<span class=hljs-title>Component</span> </span>{</code><br><code>  <span class=hljs-comment>// ...</span></code><br><code>  componentDidMount() {</code><br><code>    <span class=hljs-keyword>const</span> { fetchProductIsLoading, setProductData } = <span class=hljs-keyword>this</span>.props;</code><br><code>    <span class=hljs-comment>// turns on the loading spinner via redux</span></code><br><code>    fetchProductIsLoading();</code><br><code></code><br><code>    <span class=hljs-comment>// starts the request and puts data on the redux's store</span></code><br><code>    fetch(<span class=hljs-string>"/api/products/1/"</span>)</code><br><code>      .then(<span class=hljs-function><span class=hljs-params>response</span> =></span> response.json())</code><br><code>      .then(<span class=hljs-function><span class=hljs-params>data</span> =></span> setProductData(data));</code><br><code>  }</code><br><code>  <span class=hljs-comment>//...</span></code><br><code>  render() {</code><br><code>    <span class=hljs-keyword>const</span> { productIsLoading, productData } = <span class=hljs-keyword>this</span>.props;</code><br><code>    <span class=hljs-comment>// ...</span></code><br><code>  }</code><br><code>}</code></pre> <p>This solves most of the issues, but I would argue that this solution makes everything <strong>even more coupled</strong> and, for sure, <strong>worse to read and maintain</strong>. The root cause of the issue is that the component is still being responsible for <strong>everything</strong>: fetching the data and orchestrating redux actions, when it’s only supposed to... render stuff. The ideal flow to solve all issues, <em>at least the best for most cases</em>, would be something akin to the following flowchart: </p> <ul class=callout><li>Component mounts and dispatches isLoading signal to redux</li> <li>Redux's action starts the request and triggers isLoading reducer</li> <li>Component renders loading spinner</li> <li>Request is fullfilled asynchronously and triggers success or failure reducer </li> <li>Component renders sucess or failure based on redux's data</ul> <p>Note that the only way to remove completely the business logic from the component is to trigger the ‘Success’ and ‘Failure’ use cases <strong>outside</strong> of the component. Components should render stuff, not deal with <strong>application-wide</strong> state management. That means that the component should only dispatch one event (the <em>‘get me the data’</em> event), then react to it whenever the data is there. For that, our component code would need to be as simple as this: </p> <pre class=hljs><code><span class=hljs-keyword>export</span> <span class=hljs-keyword>default</span> <span class=hljs-class><span class=hljs-keyword>class</span> <span class=hljs-title>Product</span> <span class=hljs-keyword>extends</span> <span class=hljs-title>React</span>.<span class=hljs-title>Component</span> </span>{</code><br><code>  <span class=hljs-comment>// ...</span></code><br><code>  componentDidMount() {</code><br><code>    <span class=hljs-keyword>const</span> { fetchProduct } = <span class=hljs-keyword>this</span>.props;</code><br><code>    fetchProduct();</code><br><code>  }</code><br><code>  <span class=hljs-comment>//...</span></code><br><code>  render() {</code><br><code>    <span class=hljs-keyword>const</span> { productIsLoading, productData } = <span class=hljs-keyword>this</span>.props;</code><br><code>    <span class=hljs-comment>// ...</span></code><br><code>  }</code><br><code>}</code></pre> <p>And that means that… the actions should fetch the data? And reducers would dispatch actions? Sounds weird, right? Because it is. And it’s not what I’m suggesting whatsoever. </p> <h2>Enter the middlewares</h2> <p>To deliver the ideal data flow, <strong>redux middlewares are amazing</strong>. Let’s say we want our component to be exactly like that last bit of code. If we had something in between actions and reducers, for example, we could make this <strong>inbetween</strong> code deal with fetching the data and figuring out which reducers to fire, leaving redux to do its job of managing state and events, while leaving components focused on their jobs of rendering, and rendering only. The data flow would be something like this: </p> <ul class=callout><li>Component mounts and dispatches signal for redux to start the request </li> <li>Redux's action describes success and failure reducers, along with which function will make the request </li> <li><strong>Middleware calls the request function, saves the promise and triggers the isLoading reducer</strong></li> <li>Component renders loading spinner</li> <li><strong>Middleware awaits the request and triggers the success or failure reducer based on the action's specifications</strong></li> <li>Success or failure reducer executes business logic and persists response's data on the redux's store </li> <li>Component renders sucess or failure based on redux's data</ul> <p>With this proposed flow, our action could look like this:</p> <pre class=hljs><code><span class=hljs-keyword>export</span> <span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>fetchProduct</span>(<span class=hljs-params>id</span>) </span>{</code><br><code>  <span class=hljs-keyword>return</span> {</code><br><code>    <span class=hljs-attr>types</span>: {</code><br><code>      <span class=hljs-attr>request</span>: FETCH_PRODUCT_REQUEST,</code><br><code>      <span class=hljs-attr>success</span>: FETCH_PRODUCT_SUCCESS,</code><br><code>      <span class=hljs-attr>failure</span>: FETCH_PRODUCT_FAILURE,</code><br><code>    },</code><br><code>    <span class=hljs-attr>apiCallFunction</span>: <span class=hljs-function><span class=hljs-params>()</span> =></span> fetch(<span class=hljs-string>`/api/products/<span class=hljs-subst>${id}</span>`</span>),</code><br><code>  }</code><br><code>}</code></pre> <p>Ok, let’s slow down. What you see above is the current API for a request action, using the middleware included in our <a href=https://www.npmjs.com/package/react-redux-api-tools rel=noopener target=_blank><code>react-redux-api-tools</code></a> npm package. Dispatching this action would configure the middleware to make the request (by calling <code>apiCallFunction</code>) and to use the correct reducer whenever the request is done. Meanwhile, our component and reducers would remain unaltered: </p> <pre class=hljs><code><span class=hljs-keyword>export</span> <span class=hljs-keyword>default</span> <span class=hljs-class><span class=hljs-keyword>class</span> <span class=hljs-title>Product</span> <span class=hljs-keyword>extends</span> <span class=hljs-title>React</span>.<span class=hljs-title>Component</span> </span>{</code><br><code>  <span class=hljs-comment>// ...</span></code><br><code>  componentDidMount() {</code><br><code>    <span class=hljs-keyword>const</span> { fetchProduct } = <span class=hljs-keyword>this</span>.props;</code><br><code>    fetchProduct();</code><br><code>  }</code><br><code>  <span class=hljs-comment>//...</span></code><br><code>  render() {</code><br><code>    <span class=hljs-keyword>const</span> { productIsLoading, productData } = <span class=hljs-keyword>this</span>.props;</code><br><code>    <span class=hljs-comment>// ...</span></code><br><code>  }</code><br><code>}</code></pre> <pre class=hljs><code><span class=hljs-keyword>export</span> <span class=hljs-keyword>const</span> productReducer = <span class=hljs-function>(<span class=hljs-params>state = initialState, action</span>) =></span> {</code><br><code>  <span class=hljs-keyword>switch</span>(action.type) {</code><br><code>    <span class=hljs-keyword>case</span> FETCH_PRODUCT_REQUEST:</code><br><code>      <span class=hljs-keyword>return</span> {</code><br><code>        ...state,</code><br><code>        <span class=hljs-attr>error</span>: <span class=hljs-literal>null</span>,</code><br><code>        <span class=hljs-attr>productIsLoading</span>: <span class=hljs-literal>true</span>,</code><br><code>      }</code><br><code>    <span class=hljs-keyword>case</span> FETCH_PRODUCT_SUCCESS:</code><br><code>      <span class=hljs-comment>// here, you may execute any business logic</span></code><br><code>      businessLogic();</code><br><code></code><br><code>      <span class=hljs-keyword>return</span> {</code><br><code>        ...state,</code><br><code>        <span class=hljs-attr>error</span>: <span class=hljs-literal>null</span>,</code><br><code>        <span class=hljs-attr>productIsLoading</span>: initialState.productIsLoading,</code><br><code>        <span class=hljs-attr>productData</span>: action.response.data,</code><br><code>      }</code><br><code>    <span class=hljs-keyword>case</span> FETCH_PRODUCT_FAILURE:</code><br><code>      <span class=hljs-keyword>return</span> {</code><br><code>        ...state,</code><br><code>        <span class=hljs-attr>productIsLoading</span>: initialState.productIsLoading,</code><br><code>        <span class=hljs-attr>error</span>: action.response.data,</code><br><code>      }</code><br><code>    <span class=hljs-attr>default</span>:</code><br><code>      <span class=hljs-keyword>return</span> state;</code><br><code>  }</code><br><code>}</code></pre> <p>And <em>voilá</em>, the flow is much cleaner, simpler and decoupled!</p> <h2>If you liked this or it seems too magical...</h2> <p>Have you enjoyed this middleware API, want to develop your react-redux app like this or are just curious on how this all works? Then consider using and contributing to our <a href=https://www.npmjs.com/package/react-redux-api-tools>react-redux-api-tools</a> npm package. Bugs and feature proposals are welcome! And this is only the start; <a href=https://www.npmjs.com/package/react-redux-api-tools>react-redux-api-tools</a> has a bunch of other features I’ve not talked about. Give our docs a good read to find out how to further improve and simplify your code using our tools! Thanks, and see you later! </article></article></main></section> <nav class=svelte-1kh6syz><ul class=svelte-1kh6syz><li class=svelte-1kh6syz><a href=/ rel=prefetch class=svelte-1kh6syz>about</a></li> <li class=svelte-1kh6syz><a href=blog/page/1 rel=prefetch class=svelte-1kh6syz>blog</a></li> <li class=svelte-1kh6syz><a href=previous-talks rel=prefetch class=svelte-1kh6syz>talks</a></ul> </nav> </section></div> <script> document.addEventListener('readystatechange', function () {
			if (document.readyState === 'interactive') {
				// set theme
				document.getElementsByClassName('theme')[0].classList = window.matchMedia &&
					window.matchMedia("(prefers-color-scheme: dark)").matches
					? "theme dark-theme"
					: "theme light-theme";

				// fix height on chrome mobile
				let vh = window.innerHeight * 0.01;
				// Then we set the value in the --vh custom property to the root of the document
				document.documentElement.style.setProperty("--vh", `${vh}px`);

				const isChrome = navigator.userAgent.indexOf("Chrome") > -1;
				if (isChrome) {
					document.getElementsByClassName("theme")[0].style["min-height"] =
						"calc(var(--vh, 1vh) * 100)";
				}

				// We listen to the resize event
				window.addEventListener("resize", () => {
					// We execute the same script as before
					let vh = window.innerHeight * 0.01;
					document.documentElement.style.setProperty("--vh", `${vh}px`);

					if (isChrome) {
						document.getElementsByClassName("theme")[0].style["min-height"] =
							"calc(var(--vh, 1vh) * 100)";
					}
				});
			}
		}); </script> 